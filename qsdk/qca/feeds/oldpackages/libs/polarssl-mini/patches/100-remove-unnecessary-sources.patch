--- a/include/polarssl/asn1.h
+++ b/include/polarssl/asn1.h
@@ -27,19 +27,8 @@
 #ifndef POLARSSL_ASN1_H
 #define POLARSSL_ASN1_H
 
-#include "config.h"
-
-#if defined(POLARSSL_BIGNUM_C)
 #include "bignum.h"
-#endif
-
-#include <string.h>
 
-/** 
- * \addtogroup asn1_module
- * \{ 
- */
- 
 /**
  * \name ASN1 Error codes
  * These error codes are OR'ed to X509 error codes for
@@ -55,8 +44,6 @@
 #define POLARSSL_ERR_ASN1_MALLOC_FAILED                    -0x006A  /**< Memory allocation failed */
 #define POLARSSL_ERR_ASN1_BUF_TOO_SMALL                    -0x006C  /**< Buffer too small when writing ASN.1 data structure. */
 
-/* \} name */
-
 /**
  * \name DER constants
  * These constants comply with DER encoded the ANS1 type tags.
@@ -87,8 +74,6 @@
 #define ASN1_PRIMITIVE               0x00
 #define ASN1_CONSTRUCTED             0x20
 #define ASN1_CONTEXT_SPECIFIC        0x80
-/* \} name */
-/* \} addtogroup asn1_module */
 
 /** Returns the size of the binary string, without the trailing \\0 */
 #define OID_SIZE(x) (sizeof(x) - 1)
@@ -101,14 +86,21 @@
         ( ( OID_SIZE(oid_str) == (oid_buf)->len ) &&                \
           memcmp( (oid_str), (oid_buf)->p, (oid_buf)->len) == 0 )
 
-#ifdef __cplusplus
-extern "C" {
-#endif
 
 /**
- * \name Functions to parse ASN.1 data structures
+ * \name asn1 error codes
+ * these error codes are or'ed to x509 error codes for
+ * higher error granularity. 
+ * asn1 is a standard to specify data structures.
  * \{
  */
+#define polarssl_err_asn1_out_of_data                      -0x0060  /**< out of data when parsing an asn1 data structure. */
+#define polarssl_err_asn1_unexpected_tag                   -0x0062  /**< asn1 tag was of an unexpected value. */
+#define polarssl_err_asn1_invalid_length                   -0x0064  /**< error when trying to determine the length or invalid length. */
+#define polarssl_err_asn1_length_mismatch                  -0x0066  /**< actual length differs from expected length. */
+#define polarssl_err_asn1_invalid_data                     -0x0068  /**< data is invalid. (not used) */
+#define polarssl_err_asn1_malloc_failed                    -0x006a  /**< memory allocation failed */
+#define polarssl_err_asn1_buf_too_small                    -0x006c  /**< buffer too small when writing asn.1 data structure. */
 
 /**
  * Type-length-value structure that allows for ASN1 using DER.
@@ -185,155 +177,5 @@ int asn1_get_tag( unsigned char **p,
                   const unsigned char *end,
                   size_t *len, int tag );
 
-/**
- * \brief       Retrieve a boolean ASN.1 tag and its value.
- *              Updates the pointer to immediately behind the full tag.
- *
- * \param p     The position in the ASN.1 data
- * \param end   End of data
- * \param val   The variable that will receive the value
- *
- * \return      0 if successful or a specific ASN.1 error code.
- */
-int asn1_get_bool( unsigned char **p,
-                   const unsigned char *end,
-                   int *val );
-
-/**
- * \brief       Retrieve an integer ASN.1 tag and its value.
- *              Updates the pointer to immediately behind the full tag.
- *
- * \param p     The position in the ASN.1 data
- * \param end   End of data
- * \param val   The variable that will receive the value
- *
- * \return      0 if successful or a specific ASN.1 error code.
- */
-int asn1_get_int( unsigned char **p,
-                  const unsigned char *end,
-                  int *val );
 
-/**
- * \brief       Retrieve a bitstring ASN.1 tag and its value.
- *              Updates the pointer to immediately behind the full tag.
- *
- * \param p     The position in the ASN.1 data
- * \param end   End of data
- * \param bs    The variable that will receive the value
- *
- * \return      0 if successful or a specific ASN.1 error code.
- */
-int asn1_get_bitstring( unsigned char **p, const unsigned char *end,
-                        asn1_bitstring *bs);
-
-/**
- * \brief       Retrieve a bitstring ASN.1 tag without unused bits and its
- *              value.
- *              Updates the pointer to the beginning of the bit/octet string.
- *
- * \param p     The position in the ASN.1 data
- * \param end   End of data
- * \param len   Length of the actual bit/octect string in bytes
- *
- * \return      0 if successful or a specific ASN.1 error code.
- */
-int asn1_get_bitstring_null( unsigned char **p, const unsigned char *end,
-                             size_t *len );
-
-/**
- * \brief       Parses and splits an ASN.1 "SEQUENCE OF <tag>"
- *              Updated the pointer to immediately behind the full sequence tag.
- *
- * \param p     The position in the ASN.1 data
- * \param end   End of data
- * \param cur   First variable in the chain to fill
- * \param tag   Type of sequence
- *
- * \return      0 if successful or a specific ASN.1 error code.
- */
-int asn1_get_sequence_of( unsigned char **p,
-                          const unsigned char *end,
-                          asn1_sequence *cur,
-                          int tag);
-
-#if defined(POLARSSL_BIGNUM_C)
-/**
- * \brief       Retrieve a MPI value from an integer ASN.1 tag.
- *              Updates the pointer to immediately behind the full tag.
- *
- * \param p     The position in the ASN.1 data
- * \param end   End of data
- * \param X     The MPI that will receive the value
- *
- * \return      0 if successful or a specific ASN.1 or MPI error code.
- */
-int asn1_get_mpi( unsigned char **p,
-                  const unsigned char *end,
-                  mpi *X );
-#endif
-
-/**
- * \brief       Retrieve an AlgorithmIdentifier ASN.1 sequence.
- *              Updates the pointer to immediately behind the full
- *              AlgorithmIdentifier.
- *
- * \param p     The position in the ASN.1 data
- * \param end   End of data
- * \param alg   The buffer to receive the OID
- * \param params The buffer to receive the params (if any)
- *
- * \return      0 if successful or a specific ASN.1 or MPI error code.
- */
-int asn1_get_alg( unsigned char **p,
-                  const unsigned char *end,
-                  asn1_buf *alg, asn1_buf *params );
-
-/**
- * \brief       Retrieve an AlgorithmIdentifier ASN.1 sequence with NULL or no
- *              params.
- *              Updates the pointer to immediately behind the full
- *              AlgorithmIdentifier.
- *
- * \param p     The position in the ASN.1 data
- * \param end   End of data
- * \param alg   The buffer to receive the OID
- *
- * \return      0 if successful or a specific ASN.1 or MPI error code.
- */
-int asn1_get_alg_null( unsigned char **p,
-                       const unsigned char *end,
-                       asn1_buf *alg );
-
-/**
- * \brief       Find a specific named_data entry in a sequence or list based on
- *              the OID.
- *
- * \param list  The list to seek through
- * \param oid   The OID to look for
- * \param len   Size of the OID
- *
- * \return      NULL if not found, or a pointer to the existing entry.
- */
-asn1_named_data *asn1_find_named_data( asn1_named_data *list,
-                                       const char *oid, size_t len );
-
-/**
- * \brief       Free a asn1_named_data entry
- *
- * \param entry The named data entry to free
- */
-void asn1_free_named_data( asn1_named_data *entry );
-
-/**
- * \brief       Free all entries in a asn1_named_data list
- *              Head will be set to NULL
- *
- * \param head  Pointer to the head of the list of named data entries to free
- */
-void asn1_free_named_data_list( asn1_named_data **head );
-
-#ifdef __cplusplus
-}
 #endif
-
-#endif /* asn1.h */
--- a/include/polarssl/bignum.h
+++ b/include/polarssl/bignum.h
@@ -27,27 +27,13 @@
 #ifndef POLARSSL_BIGNUM_H
 #define POLARSSL_BIGNUM_H
 
-#include <stdio.h>
-#include <string.h>
-
-#include "config.h"
-
-#if defined(_MSC_VER) && !defined(EFIX64) && !defined(EFI32)
-#include <basetsd.h>
-#if (_MSC_VER <= 1200)
-typedef   signed short  int16_t;
-typedef unsigned short uint16_t;
-#else
-typedef  INT16  int16_t;
-typedef UINT16 uint16_t;
-#endif
-typedef  INT32  int32_t;
-typedef  INT64  int64_t;
-typedef UINT32 uint32_t;
-typedef UINT64 uint64_t;
-#else
-#include <inttypes.h>
-#endif
+#include <linux/types.h>
+
+/*
+ * Convert between bits/chars and number of limbs
+ */
+#define BITS_TO_LIMBS(i)  (((i) + biL - 1) / biL)
+#define CHARS_TO_LIMBS(i) (((i) + ciL - 1) / ciL)
 
 #define POLARSSL_ERR_MPI_FILE_IO_ERROR                     -0x0002  /**< An error occurred while reading from or writing to a file. */
 #define POLARSSL_ERR_MPI_BAD_INPUT_DATA                    -0x0004  /**< Bad input parameters to function. */
@@ -60,12 +46,12 @@ typedef UINT64 uint64_t;
 
 #define MPI_CHK(f) do { if( ( ret = f ) != 0 ) goto cleanup; } while( 0 )
 
+
 /*
  * Maximum size MPIs are allowed to grow to in number of limbs.
  */
 #define POLARSSL_MPI_MAX_LIMBS                             10000
 
-#if !defined(POLARSSL_CONFIG_OPTIONS)
 /*
  * Maximum window size used for modular exponentiation. Default: 6
  * Minimum value: 1. Maximum value: 6.
@@ -86,8 +72,6 @@ typedef UINT64 uint64_t;
  */
 #define POLARSSL_MPI_MAX_SIZE                              512      /**< Maximum number of bytes for usable MPIs. */
 
-#endif /* !POLARSSL_CONFIG_OPTIONS */
-
 #define POLARSSL_MPI_MAX_BITS                              ( 8 * POLARSSL_MPI_MAX_SIZE )    /**< Maximum number of bits for usable MPIs. */
 
 /*
@@ -112,64 +96,12 @@ typedef UINT64 uint64_t;
 #define LN_2_DIV_LN_10_SCALE100                 332
 #define POLARSSL_MPI_RW_BUFFER_SIZE             ( ((POLARSSL_MPI_MAX_BITS_SCALE100 + LN_2_DIV_LN_10_SCALE100 - 1) / LN_2_DIV_LN_10_SCALE100) + 10 + 6 )
 
-/*
- * Define the base integer type, architecture-wise
- */
-#if defined(POLARSSL_HAVE_INT8)
-typedef   signed char  t_sint;
-typedef unsigned char  t_uint;
-typedef uint16_t       t_udbl;
-#define POLARSSL_HAVE_UDBL
-#else
-#if defined(POLARSSL_HAVE_INT16)
-typedef  int16_t t_sint;
-typedef uint16_t t_uint;
-typedef uint32_t t_udbl;
-#define POLARSSL_HAVE_UDBL
-#else
-  /*
-   * 32-bit integers can be forced on 64-bit arches (eg. for testing purposes)
-   * by defining POLARSSL_HAVE_INT32 and undefining POARSSL_HAVE_ASM
-   */
-  #if ( ! defined(POLARSSL_HAVE_INT32) && \
-          defined(_MSC_VER) && defined(_M_AMD64) )
-    #define POLARSSL_HAVE_INT64
-    typedef  int64_t t_sint;
-    typedef uint64_t t_uint;
-  #else
-    #if ( ! defined(POLARSSL_HAVE_INT32) &&               \
-          defined(__GNUC__) && (                          \
-          defined(__amd64__) || defined(__x86_64__)    || \
-          defined(__ppc64__) || defined(__powerpc64__) || \
-          defined(__ia64__)  || defined(__alpha__)     || \
-          (defined(__sparc__) && defined(__arch64__))  || \
-          defined(__s390x__) ) )
-       #define POLARSSL_HAVE_INT64
-       typedef  int64_t t_sint;
-       typedef uint64_t t_uint;
-       typedef unsigned int t_udbl __attribute__((mode(TI)));
-       #define POLARSSL_HAVE_UDBL
-    #else
-       #define POLARSSL_HAVE_INT32
-       typedef  int32_t t_sint;
-       typedef uint32_t t_uint;
-       #if ( defined(_MSC_VER) && defined(_M_IX86) )
-         typedef uint64_t t_udbl;
-         #define POLARSSL_HAVE_UDBL
-       #else
-         #if defined( POLARSSL_HAVE_LONGLONG )
-           typedef unsigned long long t_udbl;
-           #define POLARSSL_HAVE_UDBL
-         #endif
-       #endif
-    #endif
-  #endif
-#endif /* POLARSSL_HAVE_INT16 */
-#endif /* POLARSSL_HAVE_INT8  */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
+
+#define POLARSSL_HAVE_LONGLONG
+#define POLARSSL_HAVE_INT32
+typedef int32_t t_sint;
+typedef uint32_t t_uint;
+typedef unsigned long long t_udbl;
 
 /**
  * \brief          MPI structure
@@ -179,8 +111,7 @@ typedef struct
     int s;              /*!<  integer sign      */
     size_t n;           /*!<  total # of limbs  */
     t_uint *p;          /*!<  pointer to limbs  */
-}
-mpi;
+} mpi;
 
 /**
  * \brief           Initialize one MPI
@@ -208,74 +139,6 @@ void mpi_free( mpi *X );
 int mpi_grow( mpi *X, size_t nblimbs );
 
 /**
- * \brief          Resize down, keeping at least the specified number of limbs
- *
- * \param X        MPI to shrink
- * \param nblimbs  The minimum number of limbs to keep
- *
- * \return         0 if successful,
- *                 POLARSSL_ERR_MPI_MALLOC_FAILED if memory allocation failed
- */
-int mpi_shrink( mpi *X, size_t nblimbs );
-
-/**
- * \brief          Copy the contents of Y into X
- *
- * \param X        Destination MPI
- * \param Y        Source MPI
- *
- * \return         0 if successful,
- *                 POLARSSL_ERR_MPI_MALLOC_FAILED if memory allocation failed
- */
-int mpi_copy( mpi *X, const mpi *Y );
-
-/**
- * \brief          Swap the contents of X and Y
- *
- * \param X        First MPI value
- * \param Y        Second MPI value
- */
-void mpi_swap( mpi *X, mpi *Y );
-
-/**
- * \brief          Safe conditional assignement X = Y if assign is 1
- *
- * \param X        MPI to conditionally assign to
- * \param Y        Value to be assigned
- * \param assign   1: perform the assignment, 0: keep X's original value
- *
- * \return         0 if successful,
- *                 POLARSSL_ERR_MPI_MALLOC_FAILED if memory allocation failed,
- *
- * \note           This function is equivalent to
- *                      if( assign ) mpi_copy( X, Y );
- *                 except that it avoids leaking any information about whether
- *                 the assignment was done or not (the above code may leak
- *                 information through branch prediction and/or memory access
- *                 patterns analysis).
- */
-int mpi_safe_cond_assign( mpi *X, const mpi *Y, unsigned char assign );
-
-/**
- * \brief          Safe conditional swap X <-> Y if swap is 1
- *
- * \param X        First mpi value
- * \param Y        Second mpi value
- * \param assign   1: perform the swap, 0: keep X and Y's original values
- *
- * \return         0 if successful,
- *                 POLARSSL_ERR_MPI_MALLOC_FAILED if memory allocation failed,
- *
- * \note           This function is equivalent to
- *                      if( assign ) mpi_swap( X, Y );
- *                 except that it avoids leaking any information about whether
- *                 the assignment was done or not (the above code may leak
- *                 information through branch prediction and/or memory access
- *                 patterns analysis).
- */
-int mpi_safe_cond_swap( mpi *X, mpi *Y, unsigned char assign );
-
-/**
  * \brief          Set value from integer
  *
  * \param X        MPI to set
@@ -287,32 +150,6 @@ int mpi_safe_cond_swap( mpi *X, mpi *Y, unsigned char assign );
 int mpi_lset( mpi *X, t_sint z );
 
 /**
- * \brief          Get a specific bit from X
- *
- * \param X        MPI to use
- * \param pos      Zero-based index of the bit in X
- *
- * \return         Either a 0 or a 1
- */
-int mpi_get_bit( const mpi *X, size_t pos );
-
-/**
- * \brief          Set a bit of X to a specific value of 0 or 1
- *
- * \note           Will grow X if necessary to set a bit to 1 in a not yet
- *                 existing limb. Will not grow if bit should be set to 0
- *
- * \param X        MPI to use
- * \param pos      Zero-based index of the bit in X
- * \param val      The value to set the bit to (0 or 1)
- *
- * \return         0 if successful,
- *                 POLARSSL_ERR_MPI_MALLOC_FAILED if memory allocation failed,
- *                 POLARSSL_ERR_MPI_BAD_INPUT_DATA if val is not 0 or 1
- */
-int mpi_set_bit( mpi *X, size_t pos, unsigned char val );
-
-/**
  * \brief          Return the number of zero-bits before the least significant
  *                 '1' bit
  *
@@ -351,73 +188,27 @@ size_t mpi_size( const mpi *X );
 int mpi_read_string( mpi *X, int radix, const char *s );
 
 /**
- * \brief          Export into an ASCII string
- *
- * \param X        Source MPI
- * \param radix    Output numeric base
- * \param s        String buffer
- * \param slen     String buffer size
- *
- * \return         0 if successful, or a POLARSSL_ERR_MPI_XXX error code.
- *                 *slen is always updated to reflect the amount
- *                 of data that has (or would have) been written.
- *
- * \note           Call this function with *slen = 0 to obtain the
- *                 minimum required buffer size in *slen.
- */
-int mpi_write_string( const mpi *X, int radix, char *s, size_t *slen );
-
-#if defined(POLARSSL_FS_IO)
-/**
- * \brief          Read X from an opened file
- *
- * \param X        Destination MPI
- * \param radix    Input numeric base
- * \param fin      Input file handle
- *
- * \return         0 if successful, POLARSSL_ERR_MPI_BUFFER_TOO_SMALL if
- *                 the file read buffer is too small or a
- *                 POLARSSL_ERR_MPI_XXX error code
- */
-int mpi_read_file( mpi *X, int radix, FILE *fin );
-
-/**
- * \brief          Write X into an opened file, or stdout if fout is NULL
- *
- * \param p        Prefix, can be NULL
- * \param X        Source MPI
- * \param radix    Output numeric base
- * \param fout     Output file handle (can be NULL)
- *
- * \return         0 if successful, or a POLARSSL_ERR_MPI_XXX error code
- *
- * \note           Set fout == NULL to print X on the console.
- */
-int mpi_write_file( const char *p, const mpi *X, int radix, FILE *fout );
-#endif /* POLARSSL_FS_IO */
-
-/**
- * \brief          Import X from unsigned binary data, big endian
- *
- * \param X        Destination MPI
- * \param buf      Input buffer
- * \param buflen   Input buffer size
- *
- * \return         0 if successful,
- *                 POLARSSL_ERR_MPI_MALLOC_FAILED if memory allocation failed
- */
+* \brief          Import X from unsigned binary data, big endian
+*
+* \param X        Destination MPI
+* \param buf      Input buffer
+* \param buflen   Input buffer size
+*
+* \return         0 if successful,
+*                 POLARSSL_ERR_MPI_MALLOC_FAILED if memory allocation failed
+*/
 int mpi_read_binary( mpi *X, const unsigned char *buf, size_t buflen );
 
 /**
- * \brief          Export X into unsigned binary data, big endian
- *
- * \param X        Source MPI
- * \param buf      Output buffer
- * \param buflen   Output buffer size
- *
- * \return         0 if successful,
- *                 POLARSSL_ERR_MPI_BUFFER_TOO_SMALL if buf isn't large enough
- */
+* \brief          Export X into unsigned binary data, big endian
+*
+* \param X        Source MPI
+* \param buf      Output buffer
+* \param buflen   Output buffer size
+*
+* \return         0 if successful,
+*                 POLARSSL_ERR_MPI_BUFFER_TOO_SMALL if buf isn't large enough
+*/
 int mpi_write_binary( const mpi *X, unsigned char *buf, size_t buflen );
 
 /**
@@ -657,88 +448,5 @@ int mpi_mod_int( t_uint *r, const mpi *A, t_sint b );
  */
 int mpi_exp_mod( mpi *X, const mpi *A, const mpi *E, const mpi *N, mpi *_RR );
 
-/**
- * \brief          Fill an MPI X with size bytes of random
- *
- * \param X        Destination MPI
- * \param size     Size in bytes
- * \param f_rng    RNG function
- * \param p_rng    RNG parameter
- *
- * \return         0 if successful,
- *                 POLARSSL_ERR_MPI_MALLOC_FAILED if memory allocation failed
- */
-int mpi_fill_random( mpi *X, size_t size,
-                     int (*f_rng)(void *, unsigned char *, size_t),
-                     void *p_rng );
-
-/**
- * \brief          Greatest common divisor: G = gcd(A, B)
- *
- * \param G        Destination MPI
- * \param A        Left-hand MPI
- * \param B        Right-hand MPI
- *
- * \return         0 if successful,
- *                 POLARSSL_ERR_MPI_MALLOC_FAILED if memory allocation failed
- */
-int mpi_gcd( mpi *G, const mpi *A, const mpi *B );
-
-/**
- * \brief          Modular inverse: X = A^-1 mod N
- *
- * \param X        Destination MPI
- * \param A        Left-hand MPI
- * \param N        Right-hand MPI
- *
- * \return         0 if successful,
- *                 POLARSSL_ERR_MPI_MALLOC_FAILED if memory allocation failed,
- *                 POLARSSL_ERR_MPI_BAD_INPUT_DATA if N is negative or nil
-                   POLARSSL_ERR_MPI_NOT_ACCEPTABLE if A has no inverse mod N
- */
-int mpi_inv_mod( mpi *X, const mpi *A, const mpi *N );
 
-/**
- * \brief          Miller-Rabin primality test
- *
- * \param X        MPI to check
- * \param f_rng    RNG function
- * \param p_rng    RNG parameter
- *
- * \return         0 if successful (probably prime),
- *                 POLARSSL_ERR_MPI_MALLOC_FAILED if memory allocation failed,
- *                 POLARSSL_ERR_MPI_NOT_ACCEPTABLE if X is not prime
- */
-int mpi_is_prime( mpi *X,
-                  int (*f_rng)(void *, unsigned char *, size_t),
-                  void *p_rng );
-
-/**
- * \brief          Prime number generation
- *
- * \param X        Destination MPI
- * \param nbits    Required size of X in bits ( 3 <= nbits <= POLARSSL_MPI_MAX_BITS )
- * \param dh_flag  If 1, then (X-1)/2 will be prime too
- * \param f_rng    RNG function
- * \param p_rng    RNG parameter
- *
- * \return         0 if successful (probably prime),
- *                 POLARSSL_ERR_MPI_MALLOC_FAILED if memory allocation failed,
- *                 POLARSSL_ERR_MPI_BAD_INPUT_DATA if nbits is < 3
- */
-int mpi_gen_prime( mpi *X, size_t nbits, int dh_flag,
-                   int (*f_rng)(void *, unsigned char *, size_t),
-                   void *p_rng );
-
-/**
- * \brief          Checkup routine
- *
- * \return         0 if successful, or 1 if the test failed
- */
-int mpi_self_test( int verbose );
-
-#ifdef __cplusplus
-}
 #endif
-
-#endif /* bignum.h */
--- a/include/polarssl/bn_mul.h
+++ b/include/polarssl/bn_mul.h
@@ -43,735 +43,6 @@
 
 #include "bignum.h"
 
-#if defined(POLARSSL_HAVE_ASM)
-
-#if defined(__GNUC__)
-#if defined(__i386__)
-
-#define MULADDC_INIT                \
-    asm( "                          \
-        movl   %%ebx, %0;           \
-        movl   %5, %%esi;           \
-        movl   %6, %%edi;           \
-        movl   %7, %%ecx;           \
-        movl   %8, %%ebx;           \
-        "
-
-#define MULADDC_CORE                \
-        "                           \
-        lodsl;                      \
-        mull   %%ebx;               \
-        addl   %%ecx,   %%eax;      \
-        adcl   $0,      %%edx;      \
-        addl   (%%edi), %%eax;      \
-        adcl   $0,      %%edx;      \
-        movl   %%edx,   %%ecx;      \
-        stosl;                      \
-        "
-
-#if defined(POLARSSL_HAVE_SSE2)
-
-#define MULADDC_HUIT                    \
-        "                               \
-        movd     %%ecx,     %%mm1;      \
-        movd     %%ebx,     %%mm0;      \
-        movd     (%%edi),   %%mm3;      \
-        paddq    %%mm3,     %%mm1;      \
-        movd     (%%esi),   %%mm2;      \
-        pmuludq  %%mm0,     %%mm2;      \
-        movd     4(%%esi),  %%mm4;      \
-        pmuludq  %%mm0,     %%mm4;      \
-        movd     8(%%esi),  %%mm6;      \
-        pmuludq  %%mm0,     %%mm6;      \
-        movd     12(%%esi), %%mm7;      \
-        pmuludq  %%mm0,     %%mm7;      \
-        paddq    %%mm2,     %%mm1;      \
-        movd     4(%%edi),  %%mm3;      \
-        paddq    %%mm4,     %%mm3;      \
-        movd     8(%%edi),  %%mm5;      \
-        paddq    %%mm6,     %%mm5;      \
-        movd     12(%%edi), %%mm4;      \
-        paddq    %%mm4,     %%mm7;      \
-        movd     %%mm1,     (%%edi);    \
-        movd     16(%%esi), %%mm2;      \
-        pmuludq  %%mm0,     %%mm2;      \
-        psrlq    $32,       %%mm1;      \
-        movd     20(%%esi), %%mm4;      \
-        pmuludq  %%mm0,     %%mm4;      \
-        paddq    %%mm3,     %%mm1;      \
-        movd     24(%%esi), %%mm6;      \
-        pmuludq  %%mm0,     %%mm6;      \
-        movd     %%mm1,     4(%%edi);   \
-        psrlq    $32,       %%mm1;      \
-        movd     28(%%esi), %%mm3;      \
-        pmuludq  %%mm0,     %%mm3;      \
-        paddq    %%mm5,     %%mm1;      \
-        movd     16(%%edi), %%mm5;      \
-        paddq    %%mm5,     %%mm2;      \
-        movd     %%mm1,     8(%%edi);   \
-        psrlq    $32,       %%mm1;      \
-        paddq    %%mm7,     %%mm1;      \
-        movd     20(%%edi), %%mm5;      \
-        paddq    %%mm5,     %%mm4;      \
-        movd     %%mm1,     12(%%edi);  \
-        psrlq    $32,       %%mm1;      \
-        paddq    %%mm2,     %%mm1;      \
-        movd     24(%%edi), %%mm5;      \
-        paddq    %%mm5,     %%mm6;      \
-        movd     %%mm1,     16(%%edi);  \
-        psrlq    $32,       %%mm1;      \
-        paddq    %%mm4,     %%mm1;      \
-        movd     28(%%edi), %%mm5;      \
-        paddq    %%mm5,     %%mm3;      \
-        movd     %%mm1,     20(%%edi);  \
-        psrlq    $32,       %%mm1;      \
-        paddq    %%mm6,     %%mm1;      \
-        movd     %%mm1,     24(%%edi);  \
-        psrlq    $32,       %%mm1;      \
-        paddq    %%mm3,     %%mm1;      \
-        movd     %%mm1,     28(%%edi);  \
-        addl     $32,       %%edi;      \
-        addl     $32,       %%esi;      \
-        psrlq    $32,       %%mm1;      \
-        movd     %%mm1,     %%ecx;      \
-        "
-
-#define MULADDC_STOP            \
-        "                       \
-        emms;                   \
-        movl   %4, %%ebx;       \
-        movl   %%ecx, %1;       \
-        movl   %%edi, %2;       \
-        movl   %%esi, %3;       \
-        "                       \
-        : "=m" (t), "=m" (c), "=m" (d), "=m" (s)        \
-        : "m" (t), "m" (s), "m" (d), "m" (c), "m" (b)   \
-        : "eax", "ecx", "edx", "esi", "edi"             \
-    );
-
-#else
-
-#define MULADDC_STOP            \
-        "                       \
-        movl   %4, %%ebx;       \
-        movl   %%ecx, %1;       \
-        movl   %%edi, %2;       \
-        movl   %%esi, %3;       \
-        "                       \
-        : "=m" (t), "=m" (c), "=m" (d), "=m" (s)        \
-        : "m" (t), "m" (s), "m" (d), "m" (c), "m" (b)   \
-        : "eax", "ecx", "edx", "esi", "edi"             \
-    );
-#endif /* SSE2 */
-#endif /* i386 */
-
-#if defined(__amd64__) || defined (__x86_64__)
-
-#define MULADDC_INIT                \
-    asm(                            \
-        "                           \
-        movq   %3, %%rsi;           \
-        movq   %4, %%rdi;           \
-        movq   %5, %%rcx;           \
-        movq   %6, %%rbx;           \
-        xorq   %%r8, %%r8;          \
-        "
-
-#define MULADDC_CORE                \
-        "                           \
-        movq   (%%rsi), %%rax;      \
-        mulq   %%rbx;               \
-        addq   $8,      %%rsi;      \
-        addq   %%rcx,   %%rax;      \
-        movq   %%r8,    %%rcx;      \
-        adcq   $0,      %%rdx;      \
-        nop;                        \
-        addq   %%rax,   (%%rdi);    \
-        adcq   %%rdx,   %%rcx;      \
-        addq   $8,      %%rdi;      \
-        "
-
-#define MULADDC_STOP                \
-        "                           \
-        movq   %%rcx, %0;           \
-        movq   %%rdi, %1;           \
-        movq   %%rsi, %2;           \
-        "                           \
-        : "=m" (c), "=m" (d), "=m" (s)                      \
-        : "m" (s), "m" (d), "m" (c), "m" (b)                \
-        : "rax", "rcx", "rdx", "rbx", "rsi", "rdi", "r8"    \
-    );
-
-#endif /* AMD64 */
-
-#if defined(__mc68020__) || defined(__mcpu32__)
-
-#define MULADDC_INIT            \
-    asm(                        \
-        "                       \
-        movl   %3, %%a2;        \
-        movl   %4, %%a3;        \
-        movl   %5, %%d3;        \
-        movl   %6, %%d2;        \
-        moveq  #0, %%d0;        \
-        "
-
-#define MULADDC_CORE            \
-        "                       \
-        movel  %%a2@+, %%d1;    \
-        mulul  %%d2, %%d4:%%d1; \
-        addl   %%d3, %%d1;      \
-        addxl  %%d0, %%d4;      \
-        moveq  #0,   %%d3;      \
-        addl   %%d1, %%a3@+;    \
-        addxl  %%d4, %%d3;      \
-        "
-
-#define MULADDC_STOP            \
-        "                       \
-        movl   %%d3, %0;        \
-        movl   %%a3, %1;        \
-        movl   %%a2, %2;        \
-        "                       \
-        : "=m" (c), "=m" (d), "=m" (s)              \
-        : "m" (s), "m" (d), "m" (c), "m" (b)        \
-        : "d0", "d1", "d2", "d3", "d4", "a2", "a3"  \
-    );
-
-#define MULADDC_HUIT                \
-        "                           \
-        movel  %%a2@+,  %%d1;       \
-        mulul  %%d2,    %%d4:%%d1;  \
-        addxl  %%d3,    %%d1;       \
-        addxl  %%d0,    %%d4;       \
-        addl   %%d1,    %%a3@+;     \
-        movel  %%a2@+,  %%d1;       \
-        mulul  %%d2,    %%d3:%%d1;  \
-        addxl  %%d4,    %%d1;       \
-        addxl  %%d0,    %%d3;       \
-        addl   %%d1,    %%a3@+;     \
-        movel  %%a2@+,  %%d1;       \
-        mulul  %%d2,    %%d4:%%d1;  \
-        addxl  %%d3,    %%d1;       \
-        addxl  %%d0,    %%d4;       \
-        addl   %%d1,    %%a3@+;     \
-        movel  %%a2@+,  %%d1;       \
-        mulul  %%d2,    %%d3:%%d1;  \
-        addxl  %%d4,    %%d1;       \
-        addxl  %%d0,    %%d3;       \
-        addl   %%d1,    %%a3@+;     \
-        movel  %%a2@+,  %%d1;       \
-        mulul  %%d2,    %%d4:%%d1;  \
-        addxl  %%d3,    %%d1;       \
-        addxl  %%d0,    %%d4;       \
-        addl   %%d1,    %%a3@+;     \
-        movel  %%a2@+,  %%d1;       \
-        mulul  %%d2,    %%d3:%%d1;  \
-        addxl  %%d4,    %%d1;       \
-        addxl  %%d0,    %%d3;       \
-        addl   %%d1,    %%a3@+;     \
-        movel  %%a2@+,  %%d1;       \
-        mulul  %%d2,    %%d4:%%d1;  \
-        addxl  %%d3,    %%d1;       \
-        addxl  %%d0,    %%d4;       \
-        addl   %%d1,    %%a3@+;     \
-        movel  %%a2@+,  %%d1;       \
-        mulul  %%d2,    %%d3:%%d1;  \
-        addxl  %%d4,    %%d1;       \
-        addxl  %%d0,    %%d3;       \
-        addl   %%d1,    %%a3@+;     \
-        addxl  %%d0,    %%d3;       \
-        "
-
-#endif /* MC68000 */
-
-#if defined(__powerpc__)   || defined(__ppc__)
-#if defined(__powerpc64__) || defined(__ppc64__)
-
-#if defined(__MACH__) && defined(__APPLE__)
-
-#define MULADDC_INIT                \
-    asm(                            \
-        "                           \
-        ld     r3, %3;              \
-        ld     r4, %4;              \
-        ld     r5, %5;              \
-        ld     r6, %6;              \
-        addi   r3, r3, -8;          \
-        addi   r4, r4, -8;          \
-        addic  r5, r5,  0;          \
-        "
-
-#define MULADDC_CORE                \
-        "                           \
-        ldu    r7, 8(r3);           \
-        mulld  r8, r7, r6;          \
-        mulhdu r9, r7, r6;          \
-        adde   r8, r8, r5;          \
-        ld     r7, 8(r4);           \
-        addze  r5, r9;              \
-        addc   r8, r8, r7;          \
-        stdu   r8, 8(r4);           \
-        "
-
-#define MULADDC_STOP                \
-        "                           \
-        addze  r5, r5;              \
-        addi   r4, r4, 8;           \
-        addi   r3, r3, 8;           \
-        std    r5, %0;              \
-        std    r4, %1;              \
-        std    r3, %2;              \
-        "                           \
-        : "=m" (c), "=m" (d), "=m" (s)              \
-        : "m" (s), "m" (d), "m" (c), "m" (b)        \
-        : "r3", "r4", "r5", "r6", "r7", "r8", "r9"  \
-    );
-
-
-#else
-
-#define MULADDC_INIT                \
-    asm(                            \
-        "                           \
-        ld     %%r3, %3;            \
-        ld     %%r4, %4;            \
-        ld     %%r5, %5;            \
-        ld     %%r6, %6;            \
-        addi   %%r3, %%r3, -8;      \
-        addi   %%r4, %%r4, -8;      \
-        addic  %%r5, %%r5,  0;      \
-        "
-
-#define MULADDC_CORE                \
-        "                           \
-        ldu    %%r7, 8(%%r3);       \
-        mulld  %%r8, %%r7, %%r6;    \
-        mulhdu %%r9, %%r7, %%r6;    \
-        adde   %%r8, %%r8, %%r5;    \
-        ld     %%r7, 8(%%r4);       \
-        addze  %%r5, %%r9;          \
-        addc   %%r8, %%r8, %%r7;    \
-        stdu   %%r8, 8(%%r4);       \
-        "
-
-#define MULADDC_STOP                \
-        "                           \
-        addze  %%r5, %%r5;          \
-        addi   %%r4, %%r4, 8;       \
-        addi   %%r3, %%r3, 8;       \
-        std    %%r5, %0;            \
-        std    %%r4, %1;            \
-        std    %%r3, %2;            \
-        "                           \
-        : "=m" (c), "=m" (d), "=m" (s)              \
-        : "m" (s), "m" (d), "m" (c), "m" (b)        \
-        : "r3", "r4", "r5", "r6", "r7", "r8", "r9"  \
-    );
-
-#endif
-
-#else /* PPC32 */
-
-#if defined(__MACH__) && defined(__APPLE__)
-
-#define MULADDC_INIT            \
-    asm(                        \
-        "                       \
-        lwz    r3, %3;          \
-        lwz    r4, %4;          \
-        lwz    r5, %5;          \
-        lwz    r6, %6;          \
-        addi   r3, r3, -4;      \
-        addi   r4, r4, -4;      \
-        addic  r5, r5,  0;      \
-        "
-
-#define MULADDC_CORE            \
-        "                       \
-        lwzu   r7, 4(r3);       \
-        mullw  r8, r7, r6;      \
-        mulhwu r9, r7, r6;      \
-        adde   r8, r8, r5;      \
-        lwz    r7, 4(r4);       \
-        addze  r5, r9;          \
-        addc   r8, r8, r7;      \
-        stwu   r8, 4(r4);       \
-        "
-
-#define MULADDC_STOP            \
-        "                       \
-        addze  r5, r5;          \
-        addi   r4, r4, 4;       \
-        addi   r3, r3, 4;       \
-        stw    r5, %0;          \
-        stw    r4, %1;          \
-        stw    r3, %2;          \
-        "                       \
-        : "=m" (c), "=m" (d), "=m" (s)              \
-        : "m" (s), "m" (d), "m" (c), "m" (b)        \
-        : "r3", "r4", "r5", "r6", "r7", "r8", "r9"  \
-    );
-
-#else
-
-#define MULADDC_INIT                \
-    asm(                            \
-        "                           \
-        lwz    %%r3, %3;            \
-        lwz    %%r4, %4;            \
-        lwz    %%r5, %5;            \
-        lwz    %%r6, %6;            \
-        addi   %%r3, %%r3, -4;      \
-        addi   %%r4, %%r4, -4;      \
-        addic  %%r5, %%r5,  0;      \
-        "
-
-#define MULADDC_CORE                \
-        "                           \
-        lwzu   %%r7, 4(%%r3);       \
-        mullw  %%r8, %%r7, %%r6;    \
-        mulhwu %%r9, %%r7, %%r6;    \
-        adde   %%r8, %%r8, %%r5;    \
-        lwz    %%r7, 4(%%r4);       \
-        addze  %%r5, %%r9;          \
-        addc   %%r8, %%r8, %%r7;    \
-        stwu   %%r8, 4(%%r4);       \
-        "
-
-#define MULADDC_STOP                \
-        "                           \
-        addze  %%r5, %%r5;          \
-        addi   %%r4, %%r4, 4;       \
-        addi   %%r3, %%r3, 4;       \
-        stw    %%r5, %0;            \
-        stw    %%r4, %1;            \
-        stw    %%r3, %2;            \
-        "                           \
-        : "=m" (c), "=m" (d), "=m" (s)              \
-        : "m" (s), "m" (d), "m" (c), "m" (b)        \
-        : "r3", "r4", "r5", "r6", "r7", "r8", "r9"  \
-    );
-
-#endif
-
-#endif /* PPC32 */
-#endif /* PPC64 */
-
-#if defined(__sparc__) && defined(__sparc64__)
-
-#define MULADDC_INIT                            \
-    asm(                                        \
-         "                                      \
-                ldx     %3, %%o0;               \
-                ldx     %4, %%o1;               \
-                ld      %5, %%o2;               \
-                ld      %6, %%o3;               \
-         "
-
-#define MULADDC_CORE                            \
-         "                                      \
-                ld      [%%o0], %%o4;           \
-                inc     4, %%o0;                \
-                ld      [%%o1], %%o5;           \
-                umul    %%o3, %%o4, %%o4;       \
-                addcc   %%o4, %%o2, %%o4;       \
-                rd      %%y, %%g1;              \
-                addx    %%g1, 0, %%g1;          \
-                addcc   %%o4, %%o5, %%o4;       \
-                st      %%o4, [%%o1];           \
-                addx    %%g1, 0, %%o2;          \
-                inc     4, %%o1;                \
-        "
-
-#define MULADDC_STOP                            \
-        "                                       \
-                st      %%o2, %0;               \
-                stx     %%o1, %1;               \
-                stx     %%o0, %2;               \
-        "                                       \
-        : "=m" (c), "=m" (d), "=m" (s)          \
-        : "m" (s), "m" (d), "m" (c), "m" (b)    \
-        : "g1", "o0", "o1", "o2", "o3", "o4",   \
-          "o5"                                  \
-        );
-#endif /* SPARCv9 */
-
-#if defined(__sparc__) && !defined(__sparc64__)
-
-#define MULADDC_INIT                            \
-    asm(                                        \
-         "                                      \
-                ld      %3, %%o0;               \
-                ld      %4, %%o1;               \
-                ld      %5, %%o2;               \
-                ld      %6, %%o3;               \
-         "
-
-#define MULADDC_CORE                            \
-         "                                      \
-                ld      [%%o0], %%o4;           \
-                inc     4, %%o0;                \
-                ld      [%%o1], %%o5;           \
-                umul    %%o3, %%o4, %%o4;       \
-                addcc   %%o4, %%o2, %%o4;       \
-                rd      %%y, %%g1;              \
-                addx    %%g1, 0, %%g1;          \
-                addcc   %%o4, %%o5, %%o4;       \
-                st      %%o4, [%%o1];           \
-                addx    %%g1, 0, %%o2;          \
-                inc     4, %%o1;                \
-        "
-
-#define MULADDC_STOP                            \
-        "                                       \
-                st      %%o2, %0;               \
-                st      %%o1, %1;               \
-                st      %%o0, %2;               \
-        "                                       \
-        : "=m" (c), "=m" (d), "=m" (s)          \
-        : "m" (s), "m" (d), "m" (c), "m" (b)    \
-        : "g1", "o0", "o1", "o2", "o3", "o4",   \
-          "o5"                                  \
-        );
-
-#endif /* SPARCv8 */
-
-#if defined(__microblaze__) || defined(microblaze)
-
-#define MULADDC_INIT            \
-    asm(                        \
-        "                       \
-        lwi   r3,   %3;         \
-        lwi   r4,   %4;         \
-        lwi   r5,   %5;         \
-        lwi   r6,   %6;         \
-        andi  r7,   r6, 0xffff; \
-        bsrli r6,   r6, 16;     \
-        "
-
-#define MULADDC_CORE            \
-        "                       \
-        lhui  r8,   r3,   0;    \
-        addi  r3,   r3,   2;    \
-        lhui  r9,   r3,   0;    \
-        addi  r3,   r3,   2;    \
-        mul   r10,  r9,  r6;    \
-        mul   r11,  r8,  r7;    \
-        mul   r12,  r9,  r7;    \
-        mul   r13,  r8,  r6;    \
-        bsrli  r8, r10,  16;    \
-        bsrli  r9, r11,  16;    \
-        add   r13, r13,  r8;    \
-        add   r13, r13,  r9;    \
-        bslli r10, r10,  16;    \
-        bslli r11, r11,  16;    \
-        add   r12, r12, r10;    \
-        addc  r13, r13,  r0;    \
-        add   r12, r12, r11;    \
-        addc  r13, r13,  r0;    \
-        lwi   r10,  r4,   0;    \
-        add   r12, r12, r10;    \
-        addc  r13, r13,  r0;    \
-        add   r12, r12,  r5;    \
-        addc   r5, r13,  r0;    \
-        swi   r12,  r4,   0;    \
-        addi   r4,  r4,   4;    \
-        "
-
-#define MULADDC_STOP            \
-        "                       \
-        swi   r5,   %0;         \
-        swi   r4,   %1;         \
-        swi   r3,   %2;         \
-        "                       \
-        : "=m" (c), "=m" (d), "=m" (s)              \
-        : "m" (s), "m" (d), "m" (c), "m" (b)        \
-        : "r3", "r4"  "r5", "r6", "r7", "r8",       \
-          "r9", "r10", "r11", "r12", "r13"          \
-    );
-
-#endif /* MicroBlaze */
-
-#if defined(__tricore__)
-
-#define MULADDC_INIT                    \
-    asm(                                \
-        "                               \
-        ld.a   %%a2, %3;                \
-        ld.a   %%a3, %4;                \
-        ld.w   %%d4, %5;                \
-        ld.w   %%d1, %6;                \
-        xor    %%d5, %%d5;              \
-        "
-
-#define MULADDC_CORE                    \
-        "                               \
-        ld.w   %%d0,   [%%a2+];         \
-        madd.u %%e2, %%e4, %%d0, %%d1;  \
-        ld.w   %%d0,   [%%a3];          \
-        addx   %%d2,    %%d2,  %%d0;    \
-        addc   %%d3,    %%d3,    0;     \
-        mov    %%d4,    %%d3;           \
-        st.w  [%%a3+],  %%d2;           \
-        "
-
-#define MULADDC_STOP                    \
-        "                               \
-        st.w   %0, %%d4;                \
-        st.a   %1, %%a3;                \
-        st.a   %2, %%a2;                \
-        "                               \
-        : "=m" (c), "=m" (d), "=m" (s)          \
-        : "m" (s), "m" (d), "m" (c), "m" (b)    \
-        : "d0", "d1", "e2", "d4", "a2", "a3"    \
-    );
-
-#endif /* TriCore */
-
-#if defined(__arm__)
-
-#if defined(__thumb__) && !defined(__thumb2__)
-
-#define MULADDC_INIT                            \
-    asm(                                        \
-         "                                      \
-            ldr    r0, %3;                      \
-            ldr    r1, %4;                      \
-            ldr    r2, %5;                      \
-            ldr    r3, %6;                      \
-            lsr    r7, r3, #16;                 \
-            mov    r9, r7;                      \
-            lsl    r7, r3, #16;                 \
-            lsr    r7, r7, #16;                 \
-            mov    r8, r7;                      \
-         "
-
-#define MULADDC_CORE                            \
-         "                                      \
-            ldmia  r0!, {r6};                   \
-            lsr    r7, r6, #16;                 \
-            lsl    r6, r6, #16;                 \
-            lsr    r6, r6, #16;                 \
-            mov    r4, r8;                      \
-            mul    r4, r6;                      \
-            mov    r3, r9;                      \
-            mul    r6, r3;                      \
-            mov    r5, r9;                      \
-            mul    r5, r7;                      \
-            mov    r3, r8;                      \
-            mul    r7, r3;                      \
-            lsr    r3, r6, #16;                 \
-            add    r5, r5, r3;                  \
-            lsr    r3, r7, #16;                 \
-            add    r5, r5, r3;                  \
-            add    r4, r4, r2;                  \
-            mov    r2, #0;                      \
-            adc    r5, r2;                      \
-            lsl    r3, r6, #16;                 \
-            add    r4, r4, r3;                  \
-            adc    r5, r2;                      \
-            lsl    r3, r7, #16;                 \
-            add    r4, r4, r3;                  \
-            adc    r5, r2;                      \
-            ldr    r3, [r1];                    \
-            add    r4, r4, r3;                  \
-            adc    r2, r5;                      \
-            stmia  r1!, {r4};                   \
-         "
-
-#define MULADDC_STOP                            \
-         "                                      \
-            str    r2, %0;                      \
-            str    r1, %1;                      \
-            str    r0, %2;                      \
-         "                                      \
-         : "=m" (c),  "=m" (d), "=m" (s)        \
-         : "m" (s), "m" (d), "m" (c), "m" (b)   \
-         : "r0", "r1", "r2", "r3", "r4", "r5",  \
-           "r6", "r7", "r8", "r9", "cc"         \
-         );
-
-#else
-
-#define MULADDC_INIT                            \
-    asm(                                        \
-         "                                     \
-            ldr    r0, %3;                      \
-            ldr    r1, %4;                      \
-            ldr    r2, %5;                      \
-            ldr    r3, %6;                      \
-         "
-
-#define MULADDC_CORE                            \
-         "                                      \
-            ldr    r4, [r0], #4;                \
-            mov    r5, #0;                      \
-            ldr    r6, [r1];                    \
-            umlal  r2, r5, r3, r4;              \
-            adds   r7, r6, r2;                  \
-            adc    r2, r5, #0;                  \
-            str    r7, [r1], #4;                \
-         "
-
-#define MULADDC_STOP                            \
-         "                                      \
-            str    r2, %0;                      \
-            str    r1, %1;                      \
-            str    r0, %2;                      \
-         "                                      \
-         : "=m" (c),  "=m" (d), "=m" (s)        \
-         : "m" (s), "m" (d), "m" (c), "m" (b)   \
-         : "r0", "r1", "r2", "r3", "r4", "r5",  \
-           "r6", "r7", "cc"                     \
-         );
-
-#endif /* Thumb */
-
-#endif /* ARMv3 */
-
-#if defined(__alpha__)
-
-#define MULADDC_INIT            \
-    asm(                        \
-        "                       \
-        ldq    $1, %3;          \
-        ldq    $2, %4;          \
-        ldq    $3, %5;          \
-        ldq    $4, %6;          \
-        "
-
-#define MULADDC_CORE            \
-        "                       \
-        ldq    $6,  0($1);      \
-        addq   $1,  8, $1;      \
-        mulq   $6, $4, $7;      \
-        umulh  $6, $4, $6;      \
-        addq   $7, $3, $7;      \
-        cmpult $7, $3, $3;      \
-        ldq    $5,  0($2);      \
-        addq   $7, $5, $7;      \
-        cmpult $7, $5, $5;      \
-        stq    $7,  0($2);      \
-        addq   $2,  8, $2;      \
-        addq   $6, $3, $3;      \
-        addq   $5, $3, $3;      \
-        "
-
-#define MULADDC_STOP                            \
-        "                       \
-        stq    $3, %0;          \
-        stq    $2, %1;          \
-        stq    $1, %2;          \
-        "                       \
-        : "=m" (c), "=m" (d), "=m" (s)              \
-        : "m" (s), "m" (d), "m" (c), "m" (b)        \
-        : "$1", "$2", "$3", "$4", "$5", "$6", "$7"  \
-    );
-#endif /* Alpha */
-
-#if defined(__mips__)
-
 #define MULADDC_INIT            \
     asm(                        \
         "                       \
@@ -810,157 +81,5 @@
         : "$9", "$10", "$11", "$12", "$13", "$14", "$15"    \
     );
 
-#endif /* MIPS */
-#endif /* GNUC */
-
-#if (defined(_MSC_VER) && defined(_M_IX86)) || defined(__WATCOMC__)
-
-#define MULADDC_INIT                            \
-    __asm   mov     esi, s                      \
-    __asm   mov     edi, d                      \
-    __asm   mov     ecx, c                      \
-    __asm   mov     ebx, b
-
-#define MULADDC_CORE                            \
-    __asm   lodsd                               \
-    __asm   mul     ebx                         \
-    __asm   add     eax, ecx                    \
-    __asm   adc     edx, 0                      \
-    __asm   add     eax, [edi]                  \
-    __asm   adc     edx, 0                      \
-    __asm   mov     ecx, edx                    \
-    __asm   stosd
-
-#if defined(POLARSSL_HAVE_SSE2)
-
-#define EMIT __asm _emit
-
-#define MULADDC_HUIT                            \
-    EMIT 0x0F  EMIT 0x6E  EMIT 0xC9             \
-    EMIT 0x0F  EMIT 0x6E  EMIT 0xC3             \
-    EMIT 0x0F  EMIT 0x6E  EMIT 0x1F             \
-    EMIT 0x0F  EMIT 0xD4  EMIT 0xCB             \
-    EMIT 0x0F  EMIT 0x6E  EMIT 0x16             \
-    EMIT 0x0F  EMIT 0xF4  EMIT 0xD0             \
-    EMIT 0x0F  EMIT 0x6E  EMIT 0x66  EMIT 0x04  \
-    EMIT 0x0F  EMIT 0xF4  EMIT 0xE0             \
-    EMIT 0x0F  EMIT 0x6E  EMIT 0x76  EMIT 0x08  \
-    EMIT 0x0F  EMIT 0xF4  EMIT 0xF0             \
-    EMIT 0x0F  EMIT 0x6E  EMIT 0x7E  EMIT 0x0C  \
-    EMIT 0x0F  EMIT 0xF4  EMIT 0xF8             \
-    EMIT 0x0F  EMIT 0xD4  EMIT 0xCA             \
-    EMIT 0x0F  EMIT 0x6E  EMIT 0x5F  EMIT 0x04  \
-    EMIT 0x0F  EMIT 0xD4  EMIT 0xDC             \
-    EMIT 0x0F  EMIT 0x6E  EMIT 0x6F  EMIT 0x08  \
-    EMIT 0x0F  EMIT 0xD4  EMIT 0xEE             \
-    EMIT 0x0F  EMIT 0x6E  EMIT 0x67  EMIT 0x0C  \
-    EMIT 0x0F  EMIT 0xD4  EMIT 0xFC             \
-    EMIT 0x0F  EMIT 0x7E  EMIT 0x0F             \
-    EMIT 0x0F  EMIT 0x6E  EMIT 0x56  EMIT 0x10  \
-    EMIT 0x0F  EMIT 0xF4  EMIT 0xD0             \
-    EMIT 0x0F  EMIT 0x73  EMIT 0xD1  EMIT 0x20  \
-    EMIT 0x0F  EMIT 0x6E  EMIT 0x66  EMIT 0x14  \
-    EMIT 0x0F  EMIT 0xF4  EMIT 0xE0             \
-    EMIT 0x0F  EMIT 0xD4  EMIT 0xCB             \
-    EMIT 0x0F  EMIT 0x6E  EMIT 0x76  EMIT 0x18  \
-    EMIT 0x0F  EMIT 0xF4  EMIT 0xF0             \
-    EMIT 0x0F  EMIT 0x7E  EMIT 0x4F  EMIT 0x04  \
-    EMIT 0x0F  EMIT 0x73  EMIT 0xD1  EMIT 0x20  \
-    EMIT 0x0F  EMIT 0x6E  EMIT 0x5E  EMIT 0x1C  \
-    EMIT 0x0F  EMIT 0xF4  EMIT 0xD8             \
-    EMIT 0x0F  EMIT 0xD4  EMIT 0xCD             \
-    EMIT 0x0F  EMIT 0x6E  EMIT 0x6F  EMIT 0x10  \
-    EMIT 0x0F  EMIT 0xD4  EMIT 0xD5             \
-    EMIT 0x0F  EMIT 0x7E  EMIT 0x4F  EMIT 0x08  \
-    EMIT 0x0F  EMIT 0x73  EMIT 0xD1  EMIT 0x20  \
-    EMIT 0x0F  EMIT 0xD4  EMIT 0xCF             \
-    EMIT 0x0F  EMIT 0x6E  EMIT 0x6F  EMIT 0x14  \
-    EMIT 0x0F  EMIT 0xD4  EMIT 0xE5             \
-    EMIT 0x0F  EMIT 0x7E  EMIT 0x4F  EMIT 0x0C  \
-    EMIT 0x0F  EMIT 0x73  EMIT 0xD1  EMIT 0x20  \
-    EMIT 0x0F  EMIT 0xD4  EMIT 0xCA             \
-    EMIT 0x0F  EMIT 0x6E  EMIT 0x6F  EMIT 0x18  \
-    EMIT 0x0F  EMIT 0xD4  EMIT 0xF5             \
-    EMIT 0x0F  EMIT 0x7E  EMIT 0x4F  EMIT 0x10  \
-    EMIT 0x0F  EMIT 0x73  EMIT 0xD1  EMIT 0x20  \
-    EMIT 0x0F  EMIT 0xD4  EMIT 0xCC             \
-    EMIT 0x0F  EMIT 0x6E  EMIT 0x6F  EMIT 0x1C  \
-    EMIT 0x0F  EMIT 0xD4  EMIT 0xDD             \
-    EMIT 0x0F  EMIT 0x7E  EMIT 0x4F  EMIT 0x14  \
-    EMIT 0x0F  EMIT 0x73  EMIT 0xD1  EMIT 0x20  \
-    EMIT 0x0F  EMIT 0xD4  EMIT 0xCE             \
-    EMIT 0x0F  EMIT 0x7E  EMIT 0x4F  EMIT 0x18  \
-    EMIT 0x0F  EMIT 0x73  EMIT 0xD1  EMIT 0x20  \
-    EMIT 0x0F  EMIT 0xD4  EMIT 0xCB             \
-    EMIT 0x0F  EMIT 0x7E  EMIT 0x4F  EMIT 0x1C  \
-    EMIT 0x83  EMIT 0xC7  EMIT 0x20             \
-    EMIT 0x83  EMIT 0xC6  EMIT 0x20             \
-    EMIT 0x0F  EMIT 0x73  EMIT 0xD1  EMIT 0x20  \
-    EMIT 0x0F  EMIT 0x7E  EMIT 0xC9
-
-#define MULADDC_STOP                            \
-    EMIT 0x0F  EMIT 0x77                        \
-    __asm   mov     c, ecx                      \
-    __asm   mov     d, edi                      \
-    __asm   mov     s, esi                      \
-
-#else
-
-#define MULADDC_STOP                            \
-    __asm   mov     c, ecx                      \
-    __asm   mov     d, edi                      \
-    __asm   mov     s, esi                      \
-
-#endif /* SSE2 */
-#endif /* MSVC */
 
-#endif /* POLARSSL_HAVE_ASM */
-
-#if !defined(MULADDC_CORE)
-#if defined(POLARSSL_HAVE_UDBL)
-
-#define MULADDC_INIT                    \
-{                                       \
-    t_udbl r;                           \
-    t_uint r0, r1;
-
-#define MULADDC_CORE                    \
-    r   = *(s++) * (t_udbl) b;          \
-    r0  = r;                            \
-    r1  = r >> biL;                     \
-    r0 += c;  r1 += (r0 <  c);          \
-    r0 += *d; r1 += (r0 < *d);          \
-    c = r1; *(d++) = r0;
-
-#define MULADDC_STOP                    \
-}
-
-#else
-#define MULADDC_INIT                    \
-{                                       \
-    t_uint s0, s1, b0, b1;              \
-    t_uint r0, r1, rx, ry;              \
-    b0 = ( b << biH ) >> biH;           \
-    b1 = ( b >> biH );
-
-#define MULADDC_CORE                    \
-    s0 = ( *s << biH ) >> biH;          \
-    s1 = ( *s >> biH ); s++;            \
-    rx = s0 * b1; r0 = s0 * b0;         \
-    ry = s1 * b0; r1 = s1 * b1;         \
-    r1 += ( rx >> biH );                \
-    r1 += ( ry >> biH );                \
-    rx <<= biH; ry <<= biH;             \
-    r0 += rx; r1 += (r0 < rx);          \
-    r0 += ry; r1 += (r0 < ry);          \
-    r0 +=  c; r1 += (r0 <  c);          \
-    r0 += *d; r1 += (r0 < *d);          \
-    c = r1; *(d++) = r0;
-
-#define MULADDC_STOP                    \
-}
-
-#endif /* C (generic)  */
-#endif /* C (longlong) */
-
-#endif /* bn_mul.h */
+#endif
--- a/include/polarssl/md.h
+++ b/include/polarssl/md.h
@@ -29,25 +29,13 @@
 #ifndef POLARSSL_MD_H
 #define POLARSSL_MD_H
 
-#include <string.h>
-
-#if defined(_MSC_VER) && !defined(inline)
-#define inline _inline
-#else
-#if defined(__ARMCC_VERSION) && !defined(inline)
-#define inline __inline
-#endif /* __ARMCC_VERSION */
-#endif /*_MSC_VER */
+#include <linux/types.h>
 
 #define POLARSSL_ERR_MD_FEATURE_UNAVAILABLE                -0x5080  /**< The selected feature is not available. */
 #define POLARSSL_ERR_MD_BAD_INPUT_DATA                     -0x5100  /**< Bad input parameters to function. */
 #define POLARSSL_ERR_MD_ALLOC_FAILED                       -0x5180  /**< Failed to allocate memory. */
 #define POLARSSL_ERR_MD_FILE_IO_ERROR                      -0x5200  /**< Opening or reading of file failed. */
 
-#ifdef __cplusplus
-extern "C" {
-#endif
-
 typedef enum {
     POLARSSL_MD_NONE=0,
     POLARSSL_MD_MD2,
@@ -61,11 +49,7 @@ typedef enum {
     POLARSSL_MD_RIPEMD160,
 } md_type_t;
 
-#if defined(POLARSSL_SHA512_C)
-#define POLARSSL_MD_MAX_SIZE         64  /* longest known is SHA512 */
-#else
 #define POLARSSL_MD_MAX_SIZE         32  /* longest known is SHA256 or less */
-#endif
 
 /**
  * Message digest information. Allows message digest functions to be called
@@ -141,25 +125,6 @@ typedef struct {
 }
 
 /**
- * \brief Returns the list of digests supported by the generic digest module.
- *
- * \return          a statically allocated array of digests, the last entry
- *                  is 0.
- */
-const int *md_list( void );
-
-/**
- * \brief           Returns the message digest information associated with the
- *                  given digest name.
- *
- * \param md_name   Name of the digest to search for.
- *
- * \return          The message digest information associated with md_name or
- *                  NULL if not found.
- */
-const md_info_t *md_info_from_string( const char *md_name );
-
-/**
  * \brief           Returns the message digest information associated with the
  *                  given digest type.
  *
@@ -171,32 +136,6 @@ const md_info_t *md_info_from_string( const char *md_name );
 const md_info_t *md_info_from_type( md_type_t md_type );
 
 /**
- * \brief          Initialises and fills the message digest context structure with
- *                 the appropriate values.
- *
- * \param ctx      context to initialise. May not be NULL. The
- *                 digest-specific context (ctx->md_ctx) must be NULL. It will
- *                 be allocated, and must be freed using md_free_ctx() later.
- * \param md_info  message digest to use.
- *
- * \returns        \c 0 on success, \c POLARSSL_ERR_MD_BAD_INPUT_DATA on
- *                 parameter failure, \c POLARSSL_ERR_MD_ALLOC_FAILED if
- *                 allocation of the digest-specific context failed.
- */
-int md_init_ctx( md_context_t *ctx, const md_info_t *md_info );
-
-/**
- * \brief          Free the message-specific context of ctx. Freeing ctx itself
- *                 remains the responsibility of the caller.
- *
- * \param ctx      Free the message-specific context
- *
- * \returns        0 on success, POLARSSL_ERR_MD_BAD_INPUT_DATA if parameter
- *                 verification fails.
- */
-int md_free_ctx( md_context_t *ctx );
-
-/**
  * \brief           Returns the size of the message digest output.
  *
  * \param md_info   message digest info
@@ -211,163 +150,4 @@ static inline unsigned char md_get_size( const md_info_t *md_info )
     return md_info->size;
 }
 
-/**
- * \brief           Returns the type of the message digest output.
- *
- * \param md_info   message digest info
- *
- * \return          type of the message digest output.
- */
-static inline md_type_t md_get_type( const md_info_t *md_info )
-{
-    if( md_info == NULL )
-        return( POLARSSL_MD_NONE );
-
-    return md_info->type;
-}
-
-/**
- * \brief           Returns the name of the message digest output.
- *
- * \param md_info   message digest info
- *
- * \return          name of the message digest output.
- */
-static inline const char *md_get_name( const md_info_t *md_info )
-{
-    if( md_info == NULL )
-        return( NULL );
-
-    return md_info->name;
-}
-
-/**
- * \brief          Set-up the given context for a new message digest
- *
- * \param ctx      generic message digest context.
- *
- * \returns        0 on success, POLARSSL_ERR_MD_BAD_INPUT_DATA if parameter
- *                 verification fails.
- */
-int md_starts( md_context_t *ctx );
-
-/**
- * \brief          Generic message digest process buffer
- *
- * \param ctx      Generic message digest context
- * \param input    buffer holding the  datal
- * \param ilen     length of the input data
- *
- * \returns        0 on success, POLARSSL_ERR_MD_BAD_INPUT_DATA if parameter
- *                 verification fails.
- */
-int md_update( md_context_t *ctx, const unsigned char *input, size_t ilen );
-
-/**
- * \brief          Generic message digest final digest
- *
- * \param ctx      Generic message digest context
- * \param output   Generic message digest checksum result
- *
- * \returns        0 on success, POLARSSL_ERR_MD_BAD_INPUT_DATA if parameter
- *                 verification fails.
- */
-int md_finish( md_context_t *ctx, unsigned char *output );
-
-/**
- * \brief          Output = message_digest( input buffer )
- *
- * \param md_info  message digest info
- * \param input    buffer holding the  data
- * \param ilen     length of the input data
- * \param output   Generic message digest checksum result
- *
- * \returns        0 on success, POLARSSL_ERR_MD_BAD_INPUT_DATA if parameter
- *                 verification fails.
- */
-int md( const md_info_t *md_info, const unsigned char *input, size_t ilen,
-        unsigned char *output );
-
-/**
- * \brief          Output = message_digest( file contents )
- *
- * \param md_info  message digest info
- * \param path     input file name
- * \param output   generic message digest checksum result
- *
- * \return         0 if successful, POLARSSL_ERR_MD_FILE_OPEN_FAILED if fopen
- *                 failed, POLARSSL_ERR_MD_FILE_READ_FAILED if fread failed,
- *                 POLARSSL_ERR_MD_BAD_INPUT_DATA if md_info was NULL.
- */
-int md_file( const md_info_t *md_info, const char *path, unsigned char *output );
-
-/**
- * \brief          Generic HMAC context setup
- *
- * \param ctx      HMAC context to be initialized
- * \param key      HMAC secret key
- * \param keylen   length of the HMAC key
- *
- * \returns        0 on success, POLARSSL_ERR_MD_BAD_INPUT_DATA if parameter
- *                 verification fails.
- */
-int md_hmac_starts( md_context_t *ctx, const unsigned char *key, size_t keylen );
-
-/**
- * \brief          Generic HMAC process buffer
- *
- * \param ctx      HMAC context
- * \param input    buffer holding the  data
- * \param ilen     length of the input data
- *
- * \returns        0 on success, POLARSSL_ERR_MD_BAD_INPUT_DATA if parameter
- *                 verification fails.
- */
-int md_hmac_update( md_context_t *ctx, const unsigned char *input, size_t ilen );
-
-/**
- * \brief          Generic HMAC final digest
- *
- * \param ctx      HMAC context
- * \param output   Generic HMAC checksum result
- *
- * \returns        0 on success, POLARSSL_ERR_MD_BAD_INPUT_DATA if parameter
- *                 verification fails.
- */
-int md_hmac_finish( md_context_t *ctx, unsigned char *output);
-
-/**
- * \brief          Generic HMAC context reset
- *
- * \param ctx      HMAC context to be reset
- *
- * \returns        0 on success, POLARSSL_ERR_MD_BAD_INPUT_DATA if parameter
- *                 verification fails.
- */
-int md_hmac_reset( md_context_t *ctx );
-
-/**
- * \brief          Output = Generic_HMAC( hmac key, input buffer )
- *
- * \param md_info  message digest info
- * \param key      HMAC secret key
- * \param keylen   length of the HMAC key
- * \param input    buffer holding the  data
- * \param ilen     length of the input data
- * \param output   Generic HMAC-result
- *
- * \returns        0 on success, POLARSSL_ERR_MD_BAD_INPUT_DATA if parameter
- *                 verification fails.
- */
-int md_hmac( const md_info_t *md_info, const unsigned char *key, size_t keylen,
-                const unsigned char *input, size_t ilen,
-                unsigned char *output );
-
-/* Internal use */
-int md_process( md_context_t *ctx, const unsigned char *data );
-
-#ifdef __cplusplus
-}
 #endif
-
-#endif /* POLARSSL_MD_H */
--- a/include/polarssl/md_wrap.h
+++ b/include/polarssl/md_wrap.h
@@ -29,39 +29,8 @@
 #ifndef POLARSSL_MD_WRAP_H
 #define POLARSSL_MD_WRAP_H
 
-#include "config.h"
 #include "md.h"
 
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#if defined(POLARSSL_MD2_C)
-extern const md_info_t md2_info;
-#endif
-#if defined(POLARSSL_MD4_C)
-extern const md_info_t md4_info;
-#endif
-#if defined(POLARSSL_MD5_C)
-extern const md_info_t md5_info;
-#endif
-#if defined(POLARSSL_RIPEMD160_C)
-extern const md_info_t ripemd160_info;
-#endif
-#if defined(POLARSSL_SHA1_C)
-extern const md_info_t sha1_info;
-#endif
-#if defined(POLARSSL_SHA256_C)
-extern const md_info_t sha224_info;
 extern const md_info_t sha256_info;
-#endif
-#if defined(POLARSSL_SHA512_C)
-extern const md_info_t sha384_info;
-extern const md_info_t sha512_info;
-#endif
 
-#ifdef __cplusplus
-}
 #endif
-
-#endif /* POLARSSL_MD_WRAP_H */
--- a/include/polarssl/oid.h
+++ b/include/polarssl/oid.h
@@ -27,21 +27,8 @@
 #ifndef POLARSSL_OID_H
 #define POLARSSL_OID_H
 
-#include <string.h>
-#include "config.h"
 #include "asn1.h"
-#include "pk.h"
-#if defined(POLARSSL_CIPHER_C)
-#include "cipher.h"
-#endif
-
-#if defined(POLARSSL_MD_C)
 #include "md.h"
-#endif
-
-#if defined(POLARSSL_X509_USE_C) || defined(POLARSSL_X509_CREATE_C)
-#include "x509.h"
-#endif
 
 #define POLARSSL_ERR_OID_NOT_FOUND                         -0x002E  /**< OID is not found. */
 
@@ -345,10 +332,6 @@
  *   ecdsa-with-SHA2(3) 4 } */
 #define OID_ECDSA_SHA512            OID_ANSI_X9_62_SIG_SHA2 "\x04"
 
-#ifdef __cplusplus
-extern "C" {
-#endif
-
 /**
  * \brief Base OID descriptor structure
  */
@@ -360,123 +343,6 @@ typedef struct {
 } oid_descriptor_t;
 
 /**
- * \brief           Translate an ASN.1 OID into its numeric representation
- *                  (e.g. "\x2A\x86\x48\x86\xF7\x0D" into "1.2.840.113549")
- *
- * \param buf       buffer to put representation in
- * \param size      size of the buffer
- * \param oid       OID to translate
- *
- * \return          POLARSSL_ERR_DEBUG_BUF_TOO_SMALL or actual length used
- */
-int oid_get_numeric_string( char *buf, size_t size, const asn1_buf *oid );
-
-#if defined(POLARSSL_X509_USE_C) || defined(POLARSSL_X509_CREATE_C)
-/**
- * \brief          Translate an X.509 extension OID into local values
- *
- * \param oid      OID to use
- * \param ext_type place to store the extension type
- *
- * \return         0 if successful, or POLARSSL_ERR_OID_NOT_FOUND
- */
-int oid_get_x509_ext_type( const asn1_buf *oid, int *ext_type );
-#endif
-
-/**
- * \brief          Translate an X.509 attribute type OID into the short name
- *                 (e.g. the OID for an X520 Common Name into "CN")
- *
- * \param oid      OID to use
- * \param short_name    place to store the string pointer
- *
- * \return         0 if successful, or POLARSSL_ERR_OID_NOT_FOUND
- */
-int oid_get_attr_short_name( const asn1_buf *oid, const char **short_name );
-
-/**
- * \brief          Translate PublicKeyAlgorithm OID into pk_type
- *
- * \param oid      OID to use
- * \param pk_alg   place to store public key algorithm
- *
- * \return         0 if successful, or POLARSSL_ERR_OID_NOT_FOUND
- */
-int oid_get_pk_alg( const asn1_buf *oid, pk_type_t *pk_alg );
-
-/**
- * \brief          Translate pk_type into PublicKeyAlgorithm OID
- *
- * \param pk_alg   Public key type to look for
- * \param oid      place to store ASN.1 OID string pointer
- * \param olen     length of the OID
- *
- * \return         0 if successful, or POLARSSL_ERR_OID_NOT_FOUND
- */
-int oid_get_oid_by_pk_alg( pk_type_t pk_alg,
-                           const char **oid, size_t *olen );
-
-#if defined(POLARSSL_ECP_C)
-/**
- * \brief          Translate NamedCurve OID into an EC group identifier
- *
- * \param oid      OID to use
- * \param grp_id   place to store group id
- *
- * \return         0 if successful, or POLARSSL_ERR_OID_NOT_FOUND
- */
-int oid_get_ec_grp( const asn1_buf *oid, ecp_group_id *grp_id );
-
-/**
- * \brief          Translate EC group identifier into NamedCurve OID
- *
- * \param grp_id   EC group identifier
- * \param oid      place to store ASN.1 OID string pointer
- * \param olen     length of the OID
- *
- * \return         0 if successful, or POLARSSL_ERR_OID_NOT_FOUND
- */
-int oid_get_oid_by_ec_grp( ecp_group_id grp_id,
-                           const char **oid, size_t *olen );
-#endif /* POLARSSL_ECP_C */
-
-#if defined(POLARSSL_MD_C)
-/**
- * \brief          Translate SignatureAlgorithm OID into md_type and pk_type
- *
- * \param oid      OID to use
- * \param md_alg   place to store message digest algorithm
- * \param pk_alg   place to store public key algorithm
- *
- * \return         0 if successful, or POLARSSL_ERR_OID_NOT_FOUND
- */
-int oid_get_sig_alg( const asn1_buf *oid,
-                     md_type_t *md_alg, pk_type_t *pk_alg );
-
-/**
- * \brief          Translate SignatureAlgorithm OID into description
- *
- * \param oid      OID to use
- * \param desc     place to store string pointer
- *
- * \return         0 if successful, or POLARSSL_ERR_OID_NOT_FOUND
- */
-int oid_get_sig_alg_desc( const asn1_buf *oid, const char **desc );
-
-/**
- * \brief          Translate md_type and pk_type into SignatureAlgorithm OID
- *
- * \param md_alg   message digest algorithm
- * \param pk_alg   public key algorithm
- * \param oid      place to store ASN.1 OID string pointer
- * \param olen     length of the OID
- *
- * \return         0 if successful, or POLARSSL_ERR_OID_NOT_FOUND
- */
-int oid_get_oid_by_sig_alg( pk_type_t pk_alg, md_type_t md_alg,
-                            const char **oid, size_t *olen );
-
-/**
  * \brief          Translate hash algorithm OID into md_type
  *
  * \param oid      OID to use
@@ -485,58 +351,5 @@ int oid_get_oid_by_sig_alg( pk_type_t pk_alg, md_type_t md_alg,
  * \return         0 if successful, or POLARSSL_ERR_OID_NOT_FOUND
  */
 int oid_get_md_alg( const asn1_buf *oid, md_type_t *md_alg );
-#endif /* POLARSSL_MD_C */
-
-/**
- * \brief          Translate Extended Key Usage OID into description
- *
- * \param oid      OID to use
- * \param desc     place to store string pointer
- *
- * \return         0 if successful, or POLARSSL_ERR_OID_NOT_FOUND
- */
-int oid_get_extended_key_usage( const asn1_buf *oid, const char **desc );
 
-/**
- * \brief          Translate md_type into hash algorithm OID
- *
- * \param md_alg   message digest algorithm
- * \param oid      place to store ASN.1 OID string pointer
- * \param olen     length of the OID
- *
- * \return         0 if successful, or POLARSSL_ERR_OID_NOT_FOUND
- */
-int oid_get_oid_by_md( md_type_t md_alg, const char **oid, size_t *olen );
-
-#if defined(POLARSSL_CIPHER_C)
-/**
- * \brief          Translate encryption algorithm OID into cipher_type
- *
- * \param oid           OID to use
- * \param cipher_alg    place to store cipher algorithm
- *
- * \return         0 if successful, or POLARSSL_ERR_OID_NOT_FOUND
- */
-int oid_get_cipher_alg( const asn1_buf *oid, cipher_type_t *cipher_alg );
-#endif /* POLARSSL_CIPHER_C */
-
-#if defined(POLARSSL_PKCS12_C)
-/**
- * \brief          Translate PKCS#12 PBE algorithm OID into md_type and
- *                 cipher_type
- *
- * \param oid           OID to use
- * \param md_alg        place to store message digest algorithm
- * \param cipher_alg    place to store cipher algorithm
- *
- * \return         0 if successful, or POLARSSL_ERR_OID_NOT_FOUND
- */
-int oid_get_pkcs12_pbe_alg( const asn1_buf *oid, md_type_t *md_alg,
-                            cipher_type_t *cipher_alg );
-#endif /* POLARSSL_PKCS12_C */
-
-#ifdef __cplusplus
-}
 #endif
-
-#endif /* oid.h */
--- a/include/polarssl/rsa.h
+++ b/include/polarssl/rsa.h
@@ -27,15 +27,9 @@
 #ifndef POLARSSL_RSA_H
 #define POLARSSL_RSA_H
 
-#include "config.h"
-
 #include "bignum.h"
 #include "md.h"
 
-#if defined(POLARSSL_THREADING_C)
-#include "threading.h"
-#endif
-
 /*
  * RSA Error codes
  */
@@ -61,16 +55,6 @@
 #define RSA_SIGN        1
 #define RSA_CRYPT       2
 
-/*
- * The above constants may be used even if the RSA module is compile out,
- * eg for alternative (PKCS#11) RSA implemenations in the PK layers.
- */
-#if defined(POLARSSL_RSA_C)
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
 /**
  * \brief          RSA context structure
  */
@@ -104,11 +88,7 @@ typedef struct
                                       specified in the md.h header file
                                       for the EME-OAEP and EMSA-PSS
                                       encoding                          */
-#if defined(POLARSSL_THREADING_C)
-    threading_mutex_t mutex;    /*!<  Thread-safety mutex       */
-#endif
-}
-rsa_context;
+} rsa_context;
 
 /**
  * \brief          Initialize an RSA context
@@ -128,43 +108,6 @@ void rsa_init( rsa_context *ctx,
                int hash_id);
 
 /**
- * \brief          Generate an RSA keypair
- *
- * \param ctx      RSA context that will hold the key
- * \param f_rng    RNG function
- * \param p_rng    RNG parameter
- * \param nbits    size of the public key in bits
- * \param exponent public exponent (e.g., 65537)
- *
- * \note           rsa_init() must be called beforehand to setup
- *                 the RSA context.
- *
- * \return         0 if successful, or an POLARSSL_ERR_RSA_XXX error code
- */
-int rsa_gen_key( rsa_context *ctx,
-                 int (*f_rng)(void *, unsigned char *, size_t),
-                 void *p_rng,
-                 unsigned int nbits, int exponent );
-
-/**
- * \brief          Check a public RSA key
- *
- * \param ctx      RSA context to be checked
- *
- * \return         0 if successful, or an POLARSSL_ERR_RSA_XXX error code
- */
-int rsa_check_pubkey( const rsa_context *ctx );
-
-/**
- * \brief          Check a private RSA key
- *
- * \param ctx      RSA context to be checked
- *
- * \return         0 if successful, or an POLARSSL_ERR_RSA_XXX error code
- */
-int rsa_check_privkey( const rsa_context *ctx );
-
-/**
  * \brief          Do an RSA public key operation
  *
  * \param ctx      RSA context
@@ -185,319 +128,6 @@ int rsa_public( rsa_context *ctx,
                 unsigned char *output );
 
 /**
- * \brief          Do an RSA private key operation
- *
- * \param ctx      RSA context
- * \param f_rng    RNG function (Needed for blinding)
- * \param p_rng    RNG parameter
- * \param input    input buffer
- * \param output   output buffer
- *
- * \return         0 if successful, or an POLARSSL_ERR_RSA_XXX error code
- *
- * \note           The input and output buffers must be large
- *                 enough (eg. 128 bytes if RSA-1024 is used).
- */
-int rsa_private( rsa_context *ctx,
-                 int (*f_rng)(void *, unsigned char *, size_t),
-                 void *p_rng,
-                 const unsigned char *input,
-                 unsigned char *output );
-
-/**
- * \brief          Generic wrapper to perform a PKCS#1 encryption using the
- *                 mode from the context. Add the message padding, then do an
- *                 RSA operation.
- *
- * \param ctx      RSA context
- * \param f_rng    RNG function (Needed for padding and PKCS#1 v2.1 encoding
- *                               and RSA_PRIVATE)
- * \param p_rng    RNG parameter
- * \param mode     RSA_PUBLIC or RSA_PRIVATE
- * \param ilen     contains the plaintext length
- * \param input    buffer holding the data to be encrypted
- * \param output   buffer that will hold the ciphertext
- *
- * \return         0 if successful, or an POLARSSL_ERR_RSA_XXX error code
- *
- * \note           The output buffer must be as large as the size
- *                 of ctx->N (eg. 128 bytes if RSA-1024 is used).
- */
-int rsa_pkcs1_encrypt( rsa_context *ctx,
-                       int (*f_rng)(void *, unsigned char *, size_t),
-                       void *p_rng,
-                       int mode, size_t ilen,
-                       const unsigned char *input,
-                       unsigned char *output );
-
-/**
- * \brief          Perform a PKCS#1 v1.5 encryption (RSAES-PKCS1-v1_5-ENCRYPT)
- *
- * \param ctx      RSA context
- * \param f_rng    RNG function (Needed for padding and RSA_PRIVATE)
- * \param p_rng    RNG parameter
- * \param mode     RSA_PUBLIC or RSA_PRIVATE
- * \param ilen     contains the plaintext length
- * \param input    buffer holding the data to be encrypted
- * \param output   buffer that will hold the ciphertext
- *
- * \return         0 if successful, or an POLARSSL_ERR_RSA_XXX error code
- *
- * \note           The output buffer must be as large as the size
- *                 of ctx->N (eg. 128 bytes if RSA-1024 is used).
- */
-int rsa_rsaes_pkcs1_v15_encrypt( rsa_context *ctx,
-                                 int (*f_rng)(void *, unsigned char *, size_t),
-                                 void *p_rng,
-                                 int mode, size_t ilen,
-                                 const unsigned char *input,
-                                 unsigned char *output );
-
-/**
- * \brief          Perform a PKCS#1 v2.1 OAEP encryption (RSAES-OAEP-ENCRYPT)
- *
- * \param ctx      RSA context
- * \param f_rng    RNG function (Needed for padding and PKCS#1 v2.1 encoding
- *                               and RSA_PRIVATE)
- * \param p_rng    RNG parameter
- * \param mode     RSA_PUBLIC or RSA_PRIVATE
- * \param label    buffer holding the custom label to use
- * \param label_len contains the label length
- * \param ilen     contains the plaintext length
- * \param input    buffer holding the data to be encrypted
- * \param output   buffer that will hold the ciphertext
- *
- * \return         0 if successful, or an POLARSSL_ERR_RSA_XXX error code
- *
- * \note           The output buffer must be as large as the size
- *                 of ctx->N (eg. 128 bytes if RSA-1024 is used).
- */
-int rsa_rsaes_oaep_encrypt( rsa_context *ctx,
-                            int (*f_rng)(void *, unsigned char *, size_t),
-                            void *p_rng,
-                            int mode,
-                            const unsigned char *label, size_t label_len,
-                            size_t ilen,
-                            const unsigned char *input,
-                            unsigned char *output );
-
-/**
- * \brief          Generic wrapper to perform a PKCS#1 decryption using the
- *                 mode from the context. Do an RSA operation, then remove
- *                 the message padding
- *
- * \param ctx      RSA context
- * \param f_rng    RNG function (Only needed for RSA_PRIVATE)
- * \param p_rng    RNG parameter
- * \param mode     RSA_PUBLIC or RSA_PRIVATE
- * \param olen     will contain the plaintext length
- * \param input    buffer holding the encrypted data
- * \param output   buffer that will hold the plaintext
- * \param output_max_len    maximum length of the output buffer
- *
- * \return         0 if successful, or an POLARSSL_ERR_RSA_XXX error code
- *
- * \note           The output buffer must be as large as the size
- *                 of ctx->N (eg. 128 bytes if RSA-1024 is used) otherwise
- *                 an error is thrown.
- */
-int rsa_pkcs1_decrypt( rsa_context *ctx,
-                       int (*f_rng)(void *, unsigned char *, size_t),
-                       void *p_rng,
-                       int mode, size_t *olen,
-                       const unsigned char *input,
-                       unsigned char *output,
-                       size_t output_max_len );
-
-/**
- * \brief          Perform a PKCS#1 v1.5 decryption (RSAES-PKCS1-v1_5-DECRYPT)
- *
- * \param ctx      RSA context
- * \param f_rng    RNG function (Only needed for RSA_PRIVATE)
- * \param p_rng    RNG parameter
- * \param mode     RSA_PUBLIC or RSA_PRIVATE
- * \param olen     will contain the plaintext length
- * \param input    buffer holding the encrypted data
- * \param output   buffer that will hold the plaintext
- * \param output_max_len    maximum length of the output buffer
- *
- * \return         0 if successful, or an POLARSSL_ERR_RSA_XXX error code
- *
- * \note           The output buffer must be as large as the size
- *                 of ctx->N (eg. 128 bytes if RSA-1024 is used) otherwise
- *                 an error is thrown.
- */
-int rsa_rsaes_pkcs1_v15_decrypt( rsa_context *ctx,
-                                 int (*f_rng)(void *, unsigned char *, size_t),
-                                 void *p_rng,
-                                 int mode, size_t *olen,
-                                 const unsigned char *input,
-                                 unsigned char *output,
-                                 size_t output_max_len );
-
-/**
- * \brief          Perform a PKCS#1 v2.1 OAEP decryption (RSAES-OAEP-DECRYPT)
- *
- * \param ctx      RSA context
- * \param f_rng    RNG function (Only needed for RSA_PRIVATE)
- * \param p_rng    RNG parameter
- * \param mode     RSA_PUBLIC or RSA_PRIVATE
- * \param label    buffer holding the custom label to use
- * \param label_len contains the label length
- * \param olen     will contain the plaintext length
- * \param input    buffer holding the encrypted data
- * \param output   buffer that will hold the plaintext
- * \param output_max_len    maximum length of the output buffer
- *
- * \return         0 if successful, or an POLARSSL_ERR_RSA_XXX error code
- *
- * \note           The output buffer must be as large as the size
- *                 of ctx->N (eg. 128 bytes if RSA-1024 is used) otherwise
- *                 an error is thrown.
- */
-int rsa_rsaes_oaep_decrypt( rsa_context *ctx,
-                            int (*f_rng)(void *, unsigned char *, size_t),
-                            void *p_rng,
-                            int mode,
-                            const unsigned char *label, size_t label_len,
-                            size_t *olen,
-                            const unsigned char *input,
-                            unsigned char *output,
-                            size_t output_max_len );
-
-/**
- * \brief          Generic wrapper to perform a PKCS#1 signature using the
- *                 mode from the context. Do a private RSA operation to sign
- *                 a message digest
- *
- * \param ctx      RSA context
- * \param f_rng    RNG function (Needed for PKCS#1 v2.1 encoding and for
- *                               RSA_PRIVATE)
- * \param p_rng    RNG parameter
- * \param mode     RSA_PUBLIC or RSA_PRIVATE
- * \param md_alg   a POLARSSL_MD_* (use POLARSSL_MD_NONE for signing raw data)
- * \param hashlen  message digest length (for POLARSSL_MD_NONE only)
- * \param hash     buffer holding the message digest
- * \param sig      buffer that will hold the ciphertext
- *
- * \return         0 if the signing operation was successful,
- *                 or an POLARSSL_ERR_RSA_XXX error code
- *
- * \note           The "sig" buffer must be as large as the size
- *                 of ctx->N (eg. 128 bytes if RSA-1024 is used).
- *
- * \note           In case of PKCS#1 v2.1 encoding keep in mind that
- *                 the hash_id in the RSA context is the one used for the
- *                 encoding. hash_id in the function call is the type of hash
- *                 that is encoded. According to RFC 3447 it is advised to
- *                 keep both hashes the same.
- */
-int rsa_pkcs1_sign( rsa_context *ctx,
-                    int (*f_rng)(void *, unsigned char *, size_t),
-                    void *p_rng,
-                    int mode,
-                    md_type_t md_alg,
-                    unsigned int hashlen,
-                    const unsigned char *hash,
-                    unsigned char *sig );
-
-/**
- * \brief          Perform a PKCS#1 v1.5 signature (RSASSA-PKCS1-v1_5-SIGN)
- *
- * \param ctx      RSA context
- * \param f_rng    RNG function (Only needed for RSA_PRIVATE)
- * \param p_rng    RNG parameter
- * \param mode     RSA_PUBLIC or RSA_PRIVATE
- * \param md_alg   a POLARSSL_MD_* (use POLARSSL_MD_NONE for signing raw data)
- * \param hashlen  message digest length (for POLARSSL_MD_NONE only)
- * \param hash     buffer holding the message digest
- * \param sig      buffer that will hold the ciphertext
- *
- * \return         0 if the signing operation was successful,
- *                 or an POLARSSL_ERR_RSA_XXX error code
- *
- * \note           The "sig" buffer must be as large as the size
- *                 of ctx->N (eg. 128 bytes if RSA-1024 is used).
- */
-int rsa_rsassa_pkcs1_v15_sign( rsa_context *ctx,
-                               int (*f_rng)(void *, unsigned char *, size_t),
-                               void *p_rng,
-                               int mode,
-                               md_type_t md_alg,
-                               unsigned int hashlen,
-                               const unsigned char *hash,
-                               unsigned char *sig );
-
-/**
- * \brief          Perform a PKCS#1 v2.1 PSS signature (RSASSA-PSS-SIGN)
- *
- * \param ctx      RSA context
- * \param f_rng    RNG function (Needed for PKCS#1 v2.1 encoding and for
- *                               RSA_PRIVATE)
- * \param p_rng    RNG parameter
- * \param mode     RSA_PUBLIC or RSA_PRIVATE
- * \param md_alg   a POLARSSL_MD_* (use POLARSSL_MD_NONE for signing raw data)
- * \param hashlen  message digest length (for POLARSSL_MD_NONE only)
- * \param hash     buffer holding the message digest
- * \param sig      buffer that will hold the ciphertext
- *
- * \return         0 if the signing operation was successful,
- *                 or an POLARSSL_ERR_RSA_XXX error code
- *
- * \note           The "sig" buffer must be as large as the size
- *                 of ctx->N (eg. 128 bytes if RSA-1024 is used).
- *
- * \note           In case of PKCS#1 v2.1 encoding keep in mind that
- *                 the hash_id in the RSA context is the one used for the
- *                 encoding. hash_id in the function call is the type of hash
- *                 that is encoded. According to RFC 3447 it is advised to
- *                 keep both hashes the same.
- */
-int rsa_rsassa_pss_sign( rsa_context *ctx,
-                         int (*f_rng)(void *, unsigned char *, size_t),
-                         void *p_rng,
-                         int mode,
-                         md_type_t md_alg,
-                         unsigned int hashlen,
-                         const unsigned char *hash,
-                         unsigned char *sig );
-
-/**
- * \brief          Generic wrapper to perform a PKCS#1 verification using the
- *                 mode from the context. Do a public RSA operation and check
- *                 the message digest
- *
- * \param ctx      points to an RSA public key
- * \param f_rng    RNG function (Only needed for RSA_PRIVATE)
- * \param p_rng    RNG parameter
- * \param mode     RSA_PUBLIC or RSA_PRIVATE
- * \param md_alg   a POLARSSL_MD_* (use POLARSSL_MD_NONE for signing raw data)
- * \param hashlen  message digest length (for POLARSSL_MD_NONE only)
- * \param hash     buffer holding the message digest
- * \param sig      buffer holding the ciphertext
- *
- * \return         0 if the verify operation was successful,
- *                 or an POLARSSL_ERR_RSA_XXX error code
- *
- * \note           The "sig" buffer must be as large as the size
- *                 of ctx->N (eg. 128 bytes if RSA-1024 is used).
- *
- * \note           In case of PKCS#1 v2.1 encoding keep in mind that
- *                 the hash_id in the RSA context is the one used for the
- *                 verification. hash_id in the function call is the type of hash
- *                 that is verified. According to RFC 3447 it is advised to
- *                 keep both hashes the same.
- */
-int rsa_pkcs1_verify( rsa_context *ctx,
-                      int (*f_rng)(void *, unsigned char *, size_t),
-                      void *p_rng,
-                      int mode,
-                      md_type_t md_alg,
-                      unsigned int hashlen,
-                      const unsigned char *hash,
-                      const unsigned char *sig );
-
-/**
  * \brief          Perform a PKCS#1 v1.5 verification (RSASSA-PKCS1-v1_5-VERIFY)
  *
  * \param ctx      points to an RSA public key
@@ -525,7 +155,9 @@ int rsa_rsassa_pkcs1_v15_verify( rsa_context *ctx,
                                  const unsigned char *sig );
 
 /**
- * \brief          Perform a PKCS#1 v2.1 PSS verification (RSASSA-PSS-VERIFY)
+ * \brief          Generic wrapper to perform a PKCS#1 verification using the
+ *                 mode from the context. Do a public RSA operation and check
+ *                 the message digest
  *
  * \param ctx      points to an RSA public key
  * \param f_rng    RNG function (Only needed for RSA_PRIVATE)
@@ -548,44 +180,14 @@ int rsa_rsassa_pkcs1_v15_verify( rsa_context *ctx,
  *                 that is verified. According to RFC 3447 it is advised to
  *                 keep both hashes the same.
  */
-int rsa_rsassa_pss_verify( rsa_context *ctx,
-                           int (*f_rng)(void *, unsigned char *, size_t),
-                           void *p_rng,
-                           int mode,
-                           md_type_t md_alg,
-                           unsigned int hashlen,
-                           const unsigned char *hash,
-                           const unsigned char *sig );
-
-/**
- * \brief          Copy the components of an RSA context
- *
- * \param dst      Destination context
- * \param src      Source context
- *
- * \return         O on success,
- *                 POLARSSL_ERR_MPI_MALLOC_FAILED on memory allocation failure
- */
-int rsa_copy( rsa_context *dst, const rsa_context *src );
-
-/**
- * \brief          Free the components of an RSA key
- *
- * \param ctx      RSA Context to free
- */
-void rsa_free( rsa_context *ctx );
+int rsa_pkcs1_verify( rsa_context *ctx,
+                      int (*f_rng)(void *, unsigned char *, size_t),
+                      void *p_rng,
+                      int mode,
+                      md_type_t md_alg,
+                      unsigned int hashlen,
+                      const unsigned char *hash,
+                      const unsigned char *sig );
 
-/**
- * \brief          Checkup routine
- *
- * \return         0 if successful, or 1 if the test failed
- */
-int rsa_self_test( int verbose );
 
-#ifdef __cplusplus
-}
 #endif
-
-#endif /* POLARSSL_RSA_C */
-
-#endif /* rsa.h */
--- a/include/polarssl/sha256.h
+++ b/include/polarssl/sha256.h
@@ -24,52 +24,33 @@
  *  with this program; if not, write to the Free Software Foundation, Inc.,
  *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
+
 #ifndef POLARSSL_SHA256_H
 #define POLARSSL_SHA256_H
 
-#include "config.h"
-
-#include <string.h>
-
-#if defined(_MSC_VER) && !defined(EFIX64) && !defined(EFI32)
-#include <basetsd.h>
-typedef UINT32 uint32_t;
-#else
-#include <inttypes.h>
-#endif
+#include <linux/types.h>
 
 #define POLARSSL_ERR_SHA256_FILE_IO_ERROR              -0x0078  /**< Read/write error in file. */
 
-#if !defined(POLARSSL_SHA256_ALT)
-// Regular implementation
-//
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
 /**
  * \brief          SHA-256 context structure
  */
 typedef struct
 {
-    uint32_t total[2];          /*!< number of bytes processed  */
-    uint32_t state[8];          /*!< intermediate digest state  */
-    unsigned char buffer[64];   /*!< data block being processed */
-
-    unsigned char ipad[64];     /*!< HMAC: inner padding        */
-    unsigned char opad[64];     /*!< HMAC: outer padding        */
-    int is224;                  /*!< 0 => SHA-256, else SHA-224 */
-}
-sha256_context;
+	uint32_t total[2];          /*!< number of bytes processed  */
+	uint32_t state[8];          /*!< intermediate digest state  */
+	unsigned char buffer[64];   /*!< data block being processed */
+	unsigned char ipad[64];     /*!< HMAC: inner padding        */
+	unsigned char opad[64];     /*!< HMAC: outer padding        */
+	int is224;                  /*!< 0 => SHA-256, else SHA-224 */
+} sha256_context;
 
 /**
  * \brief          SHA-256 context setup
  *
  * \param ctx      context to be initialized
- * \param is224    0 = use SHA256, 1 = use SHA224
  */
-void sha256_starts( sha256_context *ctx, int is224 );
+void sha256_starts( sha256_context *ctx );
 
 /**
  * \brief          SHA-256 process buffer
@@ -88,43 +69,6 @@ void sha256_update( sha256_context *ctx, const unsigned char *input, size_t ilen
  */
 void sha256_finish( sha256_context *ctx, unsigned char output[32] );
 
-/* Internal use */
-void sha256_process( sha256_context *ctx, const unsigned char data[64] );
-
-#ifdef __cplusplus
-}
-#endif
-
-#else  /* POLARSSL_SHA256_ALT */
-#include "sha256_alt.h"
-#endif /* POLARSSL_SHA256_ALT */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * \brief          Output = SHA-256( input buffer )
- *
- * \param input    buffer holding the  data
- * \param ilen     length of the input data
- * \param output   SHA-224/256 checksum result
- * \param is224    0 = use SHA256, 1 = use SHA224
- */
-void sha256( const unsigned char *input, size_t ilen,
-           unsigned char output[32], int is224 );
-
-/**
- * \brief          Output = SHA-256( file contents )
- *
- * \param path     input file name
- * \param output   SHA-224/256 checksum result
- * \param is224    0 = use SHA256, 1 = use SHA224
- *
- * \return         0 if successful, or POLARSSL_ERR_SHA256_FILE_IO_ERROR
- */
-int sha256_file( const char *path, unsigned char output[32], int is224 );
-
 /**
  * \brief          SHA-256 HMAC context setup
  *
@@ -174,15 +118,5 @@ void sha256_hmac( const unsigned char *key, size_t keylen,
                   const unsigned char *input, size_t ilen,
                   unsigned char output[32], int is224 );
 
-/**
- * \brief          Checkup routine
- *
- * \return         0 if successful, or 1 if the test failed
- */
-int sha256_self_test( int verbose );
 
-#ifdef __cplusplus
-}
 #endif
-
-#endif /* sha256.h */
--- a/library/asn1parse.c
+++ b/library/asn1parse.c
@@ -1,7 +1,7 @@
 /*
- *  Generic ASN.1 parsing
+ *  The RSA public-key cryptosystem
  *
- *  Copyright (C) 2006-2013, Brainspark B.V.
+ *  Copyright (C) 2006-2011, Brainspark B.V.
  *
  *  This file is part of PolarSSL (http://www.polarssl.org)
  *  Lead Maintainer: Paul Bakker <polarssl_maintainer at polarssl.org>
@@ -22,26 +22,16 @@
  *  with this program; if not, write to the Free Software Foundation, Inc.,
  *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
+/*
+ *  RSA was designed by Ron Rivest, Adi Shamir and Len Adleman.
+ *
+ *  http://theory.lcs.mit.edu/~rivest/rsapaper.pdf
+ *  http://www.cacr.math.uwaterloo.ca/hac/about/chap8.pdf
+ */
 
-#include "polarssl/config.h"
-
-#if defined(POLARSSL_ASN1_PARSE_C)
-
-#include "polarssl/asn1.h"
-
-#if defined(POLARSSL_BIGNUM_C)
-#include "polarssl/bignum.h"
-#endif
-
-#if defined(POLARSSL_MEMORY_C)
-#include "polarssl/memory.h"
-#else
-#define polarssl_malloc     malloc
-#define polarssl_free       free
-#endif
 
-#include <string.h>
-#include <stdlib.h>
+#include "rsa.h"
+#include "oid.h"
 
 /*
  * ASN.1 DER decoding routines
@@ -117,270 +107,4 @@ int asn1_get_tag( unsigned char **p,
     return( asn1_get_len( p, end, len ) );
 }
 
-int asn1_get_bool( unsigned char **p,
-                   const unsigned char *end,
-                   int *val )
-{
-    int ret;
-    size_t len;
-
-    if( ( ret = asn1_get_tag( p, end, &len, ASN1_BOOLEAN ) ) != 0 )
-        return( ret );
-
-    if( len != 1 )
-        return( POLARSSL_ERR_ASN1_INVALID_LENGTH );
-
-    *val = ( **p != 0 ) ? 1 : 0;
-    (*p)++;
-
-    return( 0 );
-}
-
-int asn1_get_int( unsigned char **p,
-                  const unsigned char *end,
-                  int *val )
-{
-    int ret;
-    size_t len;
-
-    if( ( ret = asn1_get_tag( p, end, &len, ASN1_INTEGER ) ) != 0 )
-        return( ret );
-
-    if( len > sizeof( int ) || ( **p & 0x80 ) != 0 )
-        return( POLARSSL_ERR_ASN1_INVALID_LENGTH );
-
-    *val = 0;
-
-    while( len-- > 0 )
-    {
-        *val = ( *val << 8 ) | **p;
-        (*p)++;
-    }
-
-    return( 0 );
-}
-
-#if defined(POLARSSL_BIGNUM_C)
-int asn1_get_mpi( unsigned char **p,
-                  const unsigned char *end,
-                  mpi *X )
-{
-    int ret;
-    size_t len;
-
-    if( ( ret = asn1_get_tag( p, end, &len, ASN1_INTEGER ) ) != 0 )
-        return( ret );
-
-    ret = mpi_read_binary( X, *p, len );
-
-    *p += len;
-
-    return( ret );
-}
-#endif /* POLARSSL_BIGNUM_C */
-
-int asn1_get_bitstring( unsigned char **p, const unsigned char *end,
-                        asn1_bitstring *bs)
-{
-    int ret;
-
-    /* Certificate type is a single byte bitstring */
-    if( ( ret = asn1_get_tag( p, end, &bs->len, ASN1_BIT_STRING ) ) != 0 )
-        return( ret );
-
-    /* Check length, subtract one for actual bit string length */
-    if ( bs->len < 1 )
-        return( POLARSSL_ERR_ASN1_OUT_OF_DATA );
-    bs->len -= 1;
-
-    /* Get number of unused bits, ensure unused bits <= 7 */
-    bs->unused_bits = **p;
-    if( bs->unused_bits > 7 )
-        return( POLARSSL_ERR_ASN1_INVALID_LENGTH );
-    (*p)++;
-
-    /* Get actual bitstring */
-    bs->p = *p;
-    *p += bs->len;
-
-    if( *p != end )
-        return( POLARSSL_ERR_ASN1_LENGTH_MISMATCH );
-
-    return 0;
-}
-
-/*
- * Get a bit string without unused bits
- */
-int asn1_get_bitstring_null( unsigned char **p, const unsigned char *end,
-                             size_t *len )
-{
-    int ret;
-
-    if( ( ret = asn1_get_tag( p, end, len, ASN1_BIT_STRING ) ) != 0 )
-        return( ret );
-
-    if( (*len)-- < 2 || *(*p)++ != 0 )
-        return( POLARSSL_ERR_ASN1_INVALID_DATA );
-
-    return( 0 );
-}
-
-
-
-/*
- *  Parses and splits an ASN.1 "SEQUENCE OF <tag>"
- */
-int asn1_get_sequence_of( unsigned char **p,
-                          const unsigned char *end,
-                          asn1_sequence *cur,
-                          int tag)
-{
-    int ret;
-    size_t len;
-    asn1_buf *buf;
-
-    /* Get main sequence tag */
-    if( ( ret = asn1_get_tag( p, end, &len,
-            ASN1_CONSTRUCTED | ASN1_SEQUENCE ) ) != 0 )
-        return( ret );
-
-    if( *p + len != end )
-        return( POLARSSL_ERR_ASN1_LENGTH_MISMATCH );
-
-    while( *p < end )
-    {
-        buf = &(cur->buf);
-        buf->tag = **p;
-
-        if( ( ret = asn1_get_tag( p, end, &buf->len, tag ) ) != 0 )
-            return( ret );
-
-        buf->p = *p;
-        *p += buf->len;
-
-        /* Allocate and assign next pointer */
-        if (*p < end)
-        {
-            cur->next = (asn1_sequence *) polarssl_malloc(
-                 sizeof( asn1_sequence ) );
-
-            if( cur->next == NULL )
-                return( POLARSSL_ERR_ASN1_MALLOC_FAILED );
-
-            cur = cur->next;
-        }
-    }
-
-    /* Set final sequence entry's next pointer to NULL */
-    cur->next = NULL;
-
-    if( *p != end )
-        return( POLARSSL_ERR_ASN1_LENGTH_MISMATCH );
-
-    return( 0 );
-}
-
-int asn1_get_alg( unsigned char **p,
-                  const unsigned char *end,
-                  asn1_buf *alg, asn1_buf *params )
-{
-    int ret;
-    size_t len;
-
-    if( ( ret = asn1_get_tag( p, end, &len,
-            ASN1_CONSTRUCTED | ASN1_SEQUENCE ) ) != 0 )
-        return( ret );
-
-    if( ( end - *p ) < 1 )
-        return( POLARSSL_ERR_ASN1_OUT_OF_DATA );
-
-    alg->tag = **p;
-    end = *p + len;
-
-    if( ( ret = asn1_get_tag( p, end, &alg->len, ASN1_OID ) ) != 0 )
-        return( ret );
-
-    alg->p = *p;
-    *p += alg->len;
-
-    if( *p == end )
-    {
-        memset( params, 0, sizeof(asn1_buf) );
-        return( 0 );
-    }
-
-    params->tag = **p;
-    (*p)++;
-
-    if( ( ret = asn1_get_len( p, end, &params->len ) ) != 0 )
-        return( ret );
-
-    params->p = *p;
-    *p += params->len;
-
-    if( *p != end )
-        return( POLARSSL_ERR_ASN1_LENGTH_MISMATCH );
-
-    return( 0 );
-}
-
-int asn1_get_alg_null( unsigned char **p,
-                       const unsigned char *end,
-                       asn1_buf *alg )
-{
-    int ret;
-    asn1_buf params;
-
-    memset( &params, 0, sizeof(asn1_buf) );
-
-    if( ( ret = asn1_get_alg( p, end, alg, &params ) ) != 0 )
-        return( ret );
-
-    if( ( params.tag != ASN1_NULL && params.tag != 0 ) || params.len != 0 )
-        return( POLARSSL_ERR_ASN1_INVALID_DATA );
-
-    return( 0 );
-}
-
-void asn1_free_named_data( asn1_named_data *cur )
-{
-    if( cur == NULL )
-        return;
-
-    polarssl_free( cur->oid.p );
-    polarssl_free( cur->val.p );
-
-    memset( cur, 0, sizeof( asn1_named_data ) );
-}
-
-void asn1_free_named_data_list( asn1_named_data **head )
-{
-    asn1_named_data *cur;
-
-    while( ( cur = *head ) != NULL )
-    {
-        *head = cur->next;
-        asn1_free_named_data( cur );
-        polarssl_free( cur );
-    }
-}
-
-asn1_named_data *asn1_find_named_data( asn1_named_data *list,
-                                       const char *oid, size_t len )
-{
-    while( list != NULL )
-    {
-        if( list->oid.len == len &&
-            memcmp( list->oid.p, oid, len ) == 0 )
-        {
-            break;
-        }
-
-        list = list->next;
-    }
-
-    return( list );
-}
 
-#endif
--- a/library/bignum.c
+++ b/library/bignum.c
@@ -30,21 +30,10 @@
  *  http://math.libtomcrypt.com/files/tommath.pdf
  */
 
-#include "polarssl/config.h"
+#include <malloc.h>
 
-#if defined(POLARSSL_BIGNUM_C)
-
-#include "polarssl/bignum.h"
-#include "polarssl/bn_mul.h"
-
-#if defined(POLARSSL_MEMORY_C)
-#include "polarssl/memory.h"
-#else
-#define polarssl_malloc     malloc
-#define polarssl_free       free
-#endif
-
-#include <stdlib.h>
+#include "bignum.h"
+#include "bn_mul.h"
 
 #define ciL    (sizeof(t_uint))         /* chars in limb  */
 #define biL    (ciL << 3)               /* bits  in limb  */
@@ -80,7 +69,7 @@ void mpi_free( mpi *X )
     if( X->p != NULL )
     {
         memset( X->p, 0, X->n * ciL );
-        polarssl_free( X->p );
+        free( X->p );
     }
 
     X->s = 1;
@@ -100,7 +89,7 @@ int mpi_grow( mpi *X, size_t nblimbs )
 
     if( X->n < nblimbs )
     {
-        if( ( p = (t_uint *) polarssl_malloc( nblimbs * ciL ) ) == NULL )
+        if( ( p = (t_uint *) malloc( nblimbs * ciL ) ) == NULL )
             return( POLARSSL_ERR_MPI_MALLOC_FAILED );
 
         memset( p, 0, nblimbs * ciL );
@@ -109,7 +98,7 @@ int mpi_grow( mpi *X, size_t nblimbs )
         {
             memcpy( p, X->p, X->n * ciL );
             memset( X->p, 0, X->n * ciL );
-            polarssl_free( X->p );
+            free( X->p );
         }
 
         X->n = nblimbs;
@@ -120,45 +109,6 @@ int mpi_grow( mpi *X, size_t nblimbs )
 }
 
 /*
- * Resize down as much as possible,
- * while keeping at least the specified number of limbs
- */
-int mpi_shrink( mpi *X, size_t nblimbs )
-{
-    t_uint *p;
-    size_t i;
-
-    /* Actually resize up in this case */
-    if( X->n <= nblimbs )
-        return( mpi_grow( X, nblimbs ) );
-
-    for( i = X->n - 1; i > 0; i-- )
-        if( X->p[i] != 0 )
-            break;
-    i++;
-
-    if( i < nblimbs )
-        i = nblimbs;
-
-    if( ( p = (t_uint *) polarssl_malloc( i * ciL ) ) == NULL )
-        return( POLARSSL_ERR_MPI_MALLOC_FAILED );
-
-    memset( p, 0, i * ciL );
-
-    if( X->p != NULL )
-    {
-        memcpy( p, X->p, i * ciL );
-        memset( X->p, 0, X->n * ciL );
-        polarssl_free( X->p );
-    }
-
-    X->n = i;
-    X->p = p;
-
-    return( 0 );
-}
-
-/*
  * Copy the contents of Y into X
  */
 int mpi_copy( mpi *X, const mpi *Y )
@@ -193,82 +143,6 @@ cleanup:
 }
 
 /*
- * Swap the contents of X and Y
- */
-void mpi_swap( mpi *X, mpi *Y )
-{
-    mpi T;
-
-    memcpy( &T,  X, sizeof( mpi ) );
-    memcpy(  X,  Y, sizeof( mpi ) );
-    memcpy(  Y, &T, sizeof( mpi ) );
-}
-
-/*
- * Conditionally assign X = Y, without leaking information
- * about whether the assignment was made or not.
- * (Leaking information about the respective sizes of X and Y is ok however.)
- */
-int mpi_safe_cond_assign( mpi *X, const mpi *Y, unsigned char assign )
-{
-    int ret = 0;
-    size_t i;
-
-    /* make sure assign is 0 or 1 */
-    assign = ( assign != 0 );
-
-    MPI_CHK( mpi_grow( X, Y->n ) );
-
-    X->s = X->s * (1 - assign) + Y->s * assign;
-
-    for( i = 0; i < Y->n; i++ )
-        X->p[i] = X->p[i] * (1 - assign) + Y->p[i] * assign;
-
-    for( ; i < X->n; i++ )
-        X->p[i] *= (1 - assign);
-
-cleanup:
-    return( ret );
-}
-
-/*
- * Conditionally swap X and Y, without leaking information
- * about whether the swap was made or not.
- * Here it is not ok to simply swap the pointers, which whould lead to
- * different memory access patterns when X and Y are used afterwards.
- */
-int mpi_safe_cond_swap( mpi *X, mpi *Y, unsigned char swap )
-{
-    int ret, s;
-    size_t i;
-    t_uint tmp;
-
-    if( X == Y )
-        return( 0 );
-
-    /* make sure swap is 0 or 1 */
-    swap = ( swap != 0 );
-
-    MPI_CHK( mpi_grow( X, Y->n ) );
-    MPI_CHK( mpi_grow( Y, X->n ) );
-
-    s = X->s;
-    X->s = X->s * (1 - swap) + Y->s * swap;
-    Y->s = Y->s * (1 - swap) +    s * swap;
-
-
-    for( i = 0; i < X->n; i++ )
-    {
-        tmp = X->p[i];
-        X->p[i] = X->p[i] * (1 - swap) + Y->p[i] * swap;
-        Y->p[i] = Y->p[i] * (1 - swap) +     tmp * swap;
-    }
-
-cleanup:
-    return( ret );
-}
-
-/*
  * Set value from integer
  */
 int mpi_lset( mpi *X, t_sint z )
@@ -287,45 +161,6 @@ cleanup:
 }
 
 /*
- * Get a specific bit
- */
-int mpi_get_bit( const mpi *X, size_t pos )
-{
-    if( X->n * biL <= pos )
-        return( 0 );
-
-    return ( X->p[pos / biL] >> ( pos % biL ) ) & 0x01;
-}
-
-/*
- * Set a bit to a specific value of 0 or 1
- */
-int mpi_set_bit( mpi *X, size_t pos, unsigned char val )
-{
-    int ret = 0;
-    size_t off = pos / biL;
-    size_t idx = pos % biL;
-
-    if( val != 0 && val != 1 )
-        return POLARSSL_ERR_MPI_BAD_INPUT_DATA;
-        
-    if( X->n * biL <= pos )
-    {
-        if( val == 0 )
-            return ( 0 );
-
-        MPI_CHK( mpi_grow( X, off + 1 ) );
-    }
-
-    X->p[off] &= ~( (t_uint) 0x01 << idx );
-    X->p[off] |= (t_uint) val << idx;
-
-cleanup:
-    
-    return( ret );
-}
-
-/*
  * Return the number of least significant bits
  */
 size_t mpi_lsb( const mpi *X )
@@ -369,7 +204,7 @@ size_t mpi_size( const mpi *X )
 /*
  * Convert an ASCII character to digit value
  */
-static int mpi_get_digit( t_uint *d, int radix, char c )
+static int mpi_get_digit( t_uint *d, int radix, char c ) //radix = 16
 {
     *d = 255;
 
@@ -453,178 +288,6 @@ cleanup:
 }
 
 /*
- * Helper to write the digits high-order first
- */
-static int mpi_write_hlp( mpi *X, int radix, char **p )
-{
-    int ret;
-    t_uint r;
-
-    if( radix < 2 || radix > 16 )
-        return( POLARSSL_ERR_MPI_BAD_INPUT_DATA );
-
-    MPI_CHK( mpi_mod_int( &r, X, radix ) );
-    MPI_CHK( mpi_div_int( X, NULL, X, radix ) );
-
-    if( mpi_cmp_int( X, 0 ) != 0 )
-        MPI_CHK( mpi_write_hlp( X, radix, p ) );
-
-    if( r < 10 )
-        *(*p)++ = (char)( r + 0x30 );
-    else
-        *(*p)++ = (char)( r + 0x37 );
-
-cleanup:
-
-    return( ret );
-}
-
-/*
- * Export into an ASCII string
- */
-int mpi_write_string( const mpi *X, int radix, char *s, size_t *slen )
-{
-    int ret = 0;
-    size_t n;
-    char *p;
-    mpi T;
-
-    if( radix < 2 || radix > 16 )
-        return( POLARSSL_ERR_MPI_BAD_INPUT_DATA );
-
-    n = mpi_msb( X );
-    if( radix >=  4 ) n >>= 1;
-    if( radix >= 16 ) n >>= 1;
-    n += 3;
-
-    if( *slen < n )
-    {
-        *slen = n;
-        return( POLARSSL_ERR_MPI_BUFFER_TOO_SMALL );
-    }
-
-    p = s;
-    mpi_init( &T );
-
-    if( X->s == -1 )
-        *p++ = '-';
-
-    if( radix == 16 )
-    {
-        int c;
-        size_t i, j, k;
-
-        for( i = X->n, k = 0; i > 0; i-- )
-        {
-            for( j = ciL; j > 0; j-- )
-            {
-                c = ( X->p[i - 1] >> ( ( j - 1 ) << 3) ) & 0xFF;
-
-                if( c == 0 && k == 0 && ( i + j + 3 ) != 0 )
-                    continue;
-
-                *(p++) = "0123456789ABCDEF" [c / 16];
-                *(p++) = "0123456789ABCDEF" [c % 16];
-                k = 1;
-            }
-        }
-    }
-    else
-    {
-        MPI_CHK( mpi_copy( &T, X ) );
-
-        if( T.s == -1 )
-            T.s = 1;
-
-        MPI_CHK( mpi_write_hlp( &T, radix, &p ) );
-    }
-
-    *p++ = '\0';
-    *slen = p - s;
-
-cleanup:
-
-    mpi_free( &T );
-
-    return( ret );
-}
-
-#if defined(POLARSSL_FS_IO)
-/*
- * Read X from an opened file
- */
-int mpi_read_file( mpi *X, int radix, FILE *fin )
-{
-    t_uint d;
-    size_t slen;
-    char *p;
-    /*
-     * Buffer should have space for (short) label and decimal formatted MPI,
-     * newline characters and '\0'
-     */
-    char s[ POLARSSL_MPI_RW_BUFFER_SIZE ];
-
-    memset( s, 0, sizeof( s ) );
-    if( fgets( s, sizeof( s ) - 1, fin ) == NULL )
-        return( POLARSSL_ERR_MPI_FILE_IO_ERROR );
-
-    slen = strlen( s );
-    if( slen == sizeof( s ) - 2 )
-        return( POLARSSL_ERR_MPI_BUFFER_TOO_SMALL );
-
-    if( s[slen - 1] == '\n' ) { slen--; s[slen] = '\0'; }
-    if( s[slen - 1] == '\r' ) { slen--; s[slen] = '\0'; }
-
-    p = s + slen;
-    while( --p >= s )
-        if( mpi_get_digit( &d, radix, *p ) != 0 )
-            break;
-
-    return( mpi_read_string( X, radix, p + 1 ) );
-}
-
-/*
- * Write X into an opened file (or stdout if fout == NULL)
- */
-int mpi_write_file( const char *p, const mpi *X, int radix, FILE *fout )
-{
-    int ret;
-    size_t n, slen, plen;
-    /*
-     * Buffer should have space for (short) label and decimal formatted MPI,
-     * newline characters and '\0'
-     */
-    char s[ POLARSSL_MPI_RW_BUFFER_SIZE ];
-
-    n = sizeof( s );
-    memset( s, 0, n );
-    n -= 2;
-
-    MPI_CHK( mpi_write_string( X, radix, s, (size_t *) &n ) );
-
-    if( p == NULL ) p = "";
-
-    plen = strlen( p );
-    slen = strlen( s );
-    s[slen++] = '\r';
-    s[slen++] = '\n';
-
-    if( fout != NULL )
-    {
-        if( fwrite( p, 1, plen, fout ) != plen ||
-            fwrite( s, 1, slen, fout ) != slen )
-            return( POLARSSL_ERR_MPI_FILE_IO_ERROR );
-    }
-    else
-        printf( "%s%s", p, s );
-
-cleanup:
-
-    return( ret );
-}
-#endif /* POLARSSL_FS_IO */
-
-/*
  * Import X from unsigned binary data, big endian
  */
 int mpi_read_binary( mpi *X, const unsigned char *buf, size_t buflen )
@@ -801,9 +464,10 @@ int mpi_cmp_mpi( const mpi *X, const mpi *Y )
         if( X->p[i - 1] != 0 )
             break;
 
-    for( j = Y->n; j > 0; j-- )
+    for( j = Y->n; j > 0; j-- ) {
         if( Y->p[j - 1] != 0 )
             break;
+    }
 
     if( i == 0 && j == 0 )
         return( 0 );
@@ -1763,553 +1427,5 @@ cleanup:
     return( ret );
 }
 
-int mpi_fill_random( mpi *X, size_t size,
-                     int (*f_rng)(void *, unsigned char *, size_t),
-                     void *p_rng )
-{
-    int ret;
-
-    MPI_CHK( mpi_grow( X, CHARS_TO_LIMBS( size ) ) );
-    MPI_CHK( mpi_lset( X, 0 ) );
-
-    MPI_CHK( f_rng( p_rng, (unsigned char *) X->p, size ) );
-
-cleanup:
-    return( ret );
-}
-
-/*
- * Modular inverse: X = A^-1 mod N  (HAC 14.61 / 14.64)
- */
-int mpi_inv_mod( mpi *X, const mpi *A, const mpi *N )
-{
-    int ret;
-    mpi G, TA, TU, U1, U2, TB, TV, V1, V2;
-
-    if( mpi_cmp_int( N, 0 ) <= 0 )
-        return( POLARSSL_ERR_MPI_BAD_INPUT_DATA );
-
-    mpi_init( &TA ); mpi_init( &TU ); mpi_init( &U1 ); mpi_init( &U2 );
-    mpi_init( &G ); mpi_init( &TB ); mpi_init( &TV );
-    mpi_init( &V1 ); mpi_init( &V2 );
-
-    MPI_CHK( mpi_gcd( &G, A, N ) );
-
-    if( mpi_cmp_int( &G, 1 ) != 0 )
-    {
-        ret = POLARSSL_ERR_MPI_NOT_ACCEPTABLE;
-        goto cleanup;
-    }
-
-    MPI_CHK( mpi_mod_mpi( &TA, A, N ) );
-    MPI_CHK( mpi_copy( &TU, &TA ) );
-    MPI_CHK( mpi_copy( &TB, N ) );
-    MPI_CHK( mpi_copy( &TV, N ) );
-
-    MPI_CHK( mpi_lset( &U1, 1 ) );
-    MPI_CHK( mpi_lset( &U2, 0 ) );
-    MPI_CHK( mpi_lset( &V1, 0 ) );
-    MPI_CHK( mpi_lset( &V2, 1 ) );
-
-    do
-    {
-        while( ( TU.p[0] & 1 ) == 0 )
-        {
-            MPI_CHK( mpi_shift_r( &TU, 1 ) );
-
-            if( ( U1.p[0] & 1 ) != 0 || ( U2.p[0] & 1 ) != 0 )
-            {
-                MPI_CHK( mpi_add_mpi( &U1, &U1, &TB ) );
-                MPI_CHK( mpi_sub_mpi( &U2, &U2, &TA ) );
-            }
-
-            MPI_CHK( mpi_shift_r( &U1, 1 ) );
-            MPI_CHK( mpi_shift_r( &U2, 1 ) );
-        }
-
-        while( ( TV.p[0] & 1 ) == 0 )
-        {
-            MPI_CHK( mpi_shift_r( &TV, 1 ) );
-
-            if( ( V1.p[0] & 1 ) != 0 || ( V2.p[0] & 1 ) != 0 )
-            {
-                MPI_CHK( mpi_add_mpi( &V1, &V1, &TB ) );
-                MPI_CHK( mpi_sub_mpi( &V2, &V2, &TA ) );
-            }
-
-            MPI_CHK( mpi_shift_r( &V1, 1 ) );
-            MPI_CHK( mpi_shift_r( &V2, 1 ) );
-        }
-
-        if( mpi_cmp_mpi( &TU, &TV ) >= 0 )
-        {
-            MPI_CHK( mpi_sub_mpi( &TU, &TU, &TV ) );
-            MPI_CHK( mpi_sub_mpi( &U1, &U1, &V1 ) );
-            MPI_CHK( mpi_sub_mpi( &U2, &U2, &V2 ) );
-        }
-        else
-        {
-            MPI_CHK( mpi_sub_mpi( &TV, &TV, &TU ) );
-            MPI_CHK( mpi_sub_mpi( &V1, &V1, &U1 ) );
-            MPI_CHK( mpi_sub_mpi( &V2, &V2, &U2 ) );
-        }
-    }
-    while( mpi_cmp_int( &TU, 0 ) != 0 );
-
-    while( mpi_cmp_int( &V1, 0 ) < 0 )
-        MPI_CHK( mpi_add_mpi( &V1, &V1, N ) );
-
-    while( mpi_cmp_mpi( &V1, N ) >= 0 )
-        MPI_CHK( mpi_sub_mpi( &V1, &V1, N ) );
-
-    MPI_CHK( mpi_copy( X, &V1 ) );
-
-cleanup:
-
-    mpi_free( &TA ); mpi_free( &TU ); mpi_free( &U1 ); mpi_free( &U2 );
-    mpi_free( &G ); mpi_free( &TB ); mpi_free( &TV );
-    mpi_free( &V1 ); mpi_free( &V2 );
-
-    return( ret );
-}
-
-#if defined(POLARSSL_GENPRIME)
-
-static const int small_prime[] =
-{
-        3,    5,    7,   11,   13,   17,   19,   23,
-       29,   31,   37,   41,   43,   47,   53,   59,
-       61,   67,   71,   73,   79,   83,   89,   97,
-      101,  103,  107,  109,  113,  127,  131,  137,
-      139,  149,  151,  157,  163,  167,  173,  179,
-      181,  191,  193,  197,  199,  211,  223,  227,
-      229,  233,  239,  241,  251,  257,  263,  269,
-      271,  277,  281,  283,  293,  307,  311,  313,
-      317,  331,  337,  347,  349,  353,  359,  367,
-      373,  379,  383,  389,  397,  401,  409,  419,
-      421,  431,  433,  439,  443,  449,  457,  461,
-      463,  467,  479,  487,  491,  499,  503,  509,
-      521,  523,  541,  547,  557,  563,  569,  571,
-      577,  587,  593,  599,  601,  607,  613,  617,
-      619,  631,  641,  643,  647,  653,  659,  661,
-      673,  677,  683,  691,  701,  709,  719,  727,
-      733,  739,  743,  751,  757,  761,  769,  773,
-      787,  797,  809,  811,  821,  823,  827,  829,
-      839,  853,  857,  859,  863,  877,  881,  883,
-      887,  907,  911,  919,  929,  937,  941,  947,
-      953,  967,  971,  977,  983,  991,  997, -103
-};
-
-/*
- * Small divisors test (X must be positive)
- *
- * Return values:
- * 0: no small factor (possible prime, more tests needed)
- * 1: certain prime
- * POLARSSL_ERR_MPI_NOT_ACCEPTABLE: certain non-prime
- * other negative: error
- */
-static int mpi_check_small_factors( const mpi *X )
-{
-    int ret = 0;
-    size_t i;
-    t_uint r;
-
-    if( ( X->p[0] & 1 ) == 0 )
-        return( POLARSSL_ERR_MPI_NOT_ACCEPTABLE );
-
-    for( i = 0; small_prime[i] > 0; i++ )
-    {
-        if( mpi_cmp_int( X, small_prime[i] ) <= 0 )
-            return( 1 );
-
-        MPI_CHK( mpi_mod_int( &r, X, small_prime[i] ) );
-
-        if( r == 0 )
-            return( POLARSSL_ERR_MPI_NOT_ACCEPTABLE );
-    }
-
-cleanup:
-    return( ret );
-}
-
-/*
- * Miller-Rabin pseudo-primality test  (HAC 4.24)
- */
-static int mpi_miller_rabin( const mpi *X,
-                             int (*f_rng)(void *, unsigned char *, size_t),
-                             void *p_rng )
-{
-    int ret;
-    size_t i, j, n, s;
-    mpi W, R, T, A, RR;
-
-    mpi_init( &W ); mpi_init( &R ); mpi_init( &T ); mpi_init( &A );
-    mpi_init( &RR );
-
-    /*
-     * W = |X| - 1
-     * R = W >> lsb( W )
-     */
-    MPI_CHK( mpi_sub_int( &W, X, 1 ) );
-    s = mpi_lsb( &W );
-    MPI_CHK( mpi_copy( &R, &W ) );
-    MPI_CHK( mpi_shift_r( &R, s ) );
-
-    i = mpi_msb( X );
-    /*
-     * HAC, table 4.4
-     */
-    n = ( ( i >= 1300 ) ?  2 : ( i >=  850 ) ?  3 :
-          ( i >=  650 ) ?  4 : ( i >=  350 ) ?  8 :
-          ( i >=  250 ) ? 12 : ( i >=  150 ) ? 18 : 27 );
-
-    for( i = 0; i < n; i++ )
-    {
-        /*
-         * pick a random A, 1 < A < |X| - 1
-         */
-        MPI_CHK( mpi_fill_random( &A, X->n * ciL, f_rng, p_rng ) );
-
-        if( mpi_cmp_mpi( &A, &W ) >= 0 )
-        {
-            j = mpi_msb( &A ) - mpi_msb( &W );
-            MPI_CHK( mpi_shift_r( &A, j + 1 ) );
-        }
-        A.p[0] |= 3;
-
-        /*
-         * A = A^R mod |X|
-         */
-        MPI_CHK( mpi_exp_mod( &A, &A, &R, X, &RR ) );
-
-        if( mpi_cmp_mpi( &A, &W ) == 0 ||
-            mpi_cmp_int( &A,  1 ) == 0 )
-            continue;
-
-        j = 1;
-        while( j < s && mpi_cmp_mpi( &A, &W ) != 0 )
-        {
-            /*
-             * A = A * A mod |X|
-             */
-            MPI_CHK( mpi_mul_mpi( &T, &A, &A ) );
-            MPI_CHK( mpi_mod_mpi( &A, &T, X  ) );
-
-            if( mpi_cmp_int( &A, 1 ) == 0 )
-                break;
-
-            j++;
-        }
-
-        /*
-         * not prime if A != |X| - 1 or A == 1
-         */
-        if( mpi_cmp_mpi( &A, &W ) != 0 ||
-            mpi_cmp_int( &A,  1 ) == 0 )
-        {
-            ret = POLARSSL_ERR_MPI_NOT_ACCEPTABLE;
-            break;
-        }
-    }
-
-cleanup:
-    mpi_free( &W ); mpi_free( &R ); mpi_free( &T ); mpi_free( &A );
-    mpi_free( &RR );
-
-    return( ret );
-}
-
-/*
- * Pseudo-primality test: small factors, then Miller-Rabin
- */
-int mpi_is_prime( mpi *X,
-                  int (*f_rng)(void *, unsigned char *, size_t),
-                  void *p_rng )
-{
-    int ret;
-    const mpi XX = { 1, X->n, X->p }; /* Abs(X) */
-
-    if( mpi_cmp_int( &XX, 0 ) == 0 ||
-        mpi_cmp_int( &XX, 1 ) == 0 )
-        return( POLARSSL_ERR_MPI_NOT_ACCEPTABLE );
-
-    if( mpi_cmp_int( &XX, 2 ) == 0 )
-        return( 0 );
-
-    if( ( ret = mpi_check_small_factors( &XX ) ) != 0 )
-    {
-        if( ret == 1 )
-            return( 0 );
-
-        return( ret );
-    }
-
-    return( mpi_miller_rabin( &XX, f_rng, p_rng ) );
-}
-
-/*
- * Prime number generation
- */
-int mpi_gen_prime( mpi *X, size_t nbits, int dh_flag,
-                   int (*f_rng)(void *, unsigned char *, size_t),
-                   void *p_rng )
-{
-    int ret;
-    size_t k, n;
-    t_uint r;
-    mpi Y;
-
-    if( nbits < 3 || nbits > POLARSSL_MPI_MAX_BITS )
-        return( POLARSSL_ERR_MPI_BAD_INPUT_DATA );
-
-    mpi_init( &Y );
-
-    n = BITS_TO_LIMBS( nbits );
-
-    MPI_CHK( mpi_fill_random( X, n * ciL, f_rng, p_rng ) );
-
-    k = mpi_msb( X );
-    if( k < nbits ) MPI_CHK( mpi_shift_l( X, nbits - k ) );
-    if( k > nbits ) MPI_CHK( mpi_shift_r( X, k - nbits ) );
-
-    X->p[0] |= 3;
-
-    if( dh_flag == 0 )
-    {
-        while( ( ret = mpi_is_prime( X, f_rng, p_rng ) ) != 0 )
-        {
-            if( ret != POLARSSL_ERR_MPI_NOT_ACCEPTABLE )
-                goto cleanup;
-
-            MPI_CHK( mpi_add_int( X, X, 2 ) );
-        }
-    }
-    else
-    {
-        /*
-         * An necessary condition for Y and X = 2Y + 1 to be prime
-         * is X = 2 mod 3 (which is equivalent to Y = 2 mod 3).
-         * Make sure it is satisfied, while keeping X = 3 mod 4
-         */
-        MPI_CHK( mpi_mod_int( &r, X, 3 ) );
-        if( r == 0 )
-            MPI_CHK( mpi_add_int( X, X, 8 ) );
-        else if( r == 1 )
-            MPI_CHK( mpi_add_int( X, X, 4 ) );
-
-        /* Set Y = (X-1) / 2, which is X / 2 because X is odd */
-        MPI_CHK( mpi_copy( &Y, X ) );
-        MPI_CHK( mpi_shift_r( &Y, 1 ) );
-
-        while( 1 )
-        {
-            /*
-             * First, check small factors for X and Y
-             * before doing Miller-Rabin on any of them
-             */
-            if( ( ret = mpi_check_small_factors(  X         ) ) == 0 &&
-                ( ret = mpi_check_small_factors( &Y         ) ) == 0 &&
-                ( ret = mpi_miller_rabin(  X, f_rng, p_rng  ) ) == 0 &&
-                ( ret = mpi_miller_rabin( &Y, f_rng, p_rng  ) ) == 0 )
-            {
-                break;
-            }
-
-            if( ret != POLARSSL_ERR_MPI_NOT_ACCEPTABLE )
-                goto cleanup;
-
-            /*
-             * Next candidates. We want to preserve Y = (X-1) / 2 and
-             * Y = 1 mod 2 and Y = 2 mod 3 (eq X = 3 mod 4 and X = 2 mod 3)
-             * so up Y by 6 and X by 12.
-             */
-            MPI_CHK( mpi_add_int(  X,  X, 12 ) );
-            MPI_CHK( mpi_add_int( &Y, &Y, 6  ) );
-        }
-    }
-
-cleanup:
-
-    mpi_free( &Y );
-
-    return( ret );
-}
-
-#endif /* POLARSSL_GENPRIME */
-
-#if defined(POLARSSL_SELF_TEST)
-
-#define GCD_PAIR_COUNT  3
 
-static const int gcd_pairs[GCD_PAIR_COUNT][3] =
-{
-    { 693, 609, 21 },
-    { 1764, 868, 28 },
-    { 768454923, 542167814, 1 }
-};
 
-/*
- * Checkup routine
- */
-int mpi_self_test( int verbose )
-{
-    int ret, i;
-    mpi A, E, N, X, Y, U, V;
-
-    mpi_init( &A ); mpi_init( &E ); mpi_init( &N ); mpi_init( &X );
-    mpi_init( &Y ); mpi_init( &U ); mpi_init( &V );
-
-    MPI_CHK( mpi_read_string( &A, 16,
-        "EFE021C2645FD1DC586E69184AF4A31E" \
-        "D5F53E93B5F123FA41680867BA110131" \
-        "944FE7952E2517337780CB0DB80E61AA" \
-        "E7C8DDC6C5C6AADEB34EB38A2F40D5E6" ) );
-
-    MPI_CHK( mpi_read_string( &E, 16,
-        "B2E7EFD37075B9F03FF989C7C5051C20" \
-        "34D2A323810251127E7BF8625A4F49A5" \
-        "F3E27F4DA8BD59C47D6DAABA4C8127BD" \
-        "5B5C25763222FEFCCFC38B832366C29E" ) );
-
-    MPI_CHK( mpi_read_string( &N, 16,
-        "0066A198186C18C10B2F5ED9B522752A" \
-        "9830B69916E535C8F047518A889A43A5" \
-        "94B6BED27A168D31D4A52F88925AA8F5" ) );
-
-    MPI_CHK( mpi_mul_mpi( &X, &A, &N ) );
-
-    MPI_CHK( mpi_read_string( &U, 16,
-        "602AB7ECA597A3D6B56FF9829A5E8B85" \
-        "9E857EA95A03512E2BAE7391688D264A" \
-        "A5663B0341DB9CCFD2C4C5F421FEC814" \
-        "8001B72E848A38CAE1C65F78E56ABDEF" \
-        "E12D3C039B8A02D6BE593F0BBBDA56F1" \
-        "ECF677152EF804370C1A305CAF3B5BF1" \
-        "30879B56C61DE584A0F53A2447A51E" ) );
-
-    if( verbose != 0 )
-        printf( "  MPI test #1 (mul_mpi): " );
-
-    if( mpi_cmp_mpi( &X, &U ) != 0 )
-    {
-        if( verbose != 0 )
-            printf( "failed\n" );
-
-        ret = 1;
-        goto cleanup;
-    }
-
-    if( verbose != 0 )
-        printf( "passed\n" );
-
-    MPI_CHK( mpi_div_mpi( &X, &Y, &A, &N ) );
-
-    MPI_CHK( mpi_read_string( &U, 16,
-        "256567336059E52CAE22925474705F39A94" ) );
-
-    MPI_CHK( mpi_read_string( &V, 16,
-        "6613F26162223DF488E9CD48CC132C7A" \
-        "0AC93C701B001B092E4E5B9F73BCD27B" \
-        "9EE50D0657C77F374E903CDFA4C642" ) );
-
-    if( verbose != 0 )
-        printf( "  MPI test #2 (div_mpi): " );
-
-    if( mpi_cmp_mpi( &X, &U ) != 0 ||
-        mpi_cmp_mpi( &Y, &V ) != 0 )
-    {
-        if( verbose != 0 )
-            printf( "failed\n" );
-
-        ret = 1;
-        goto cleanup;
-    }
-
-    if( verbose != 0 )
-        printf( "passed\n" );
-
-    MPI_CHK( mpi_exp_mod( &X, &A, &E, &N, NULL ) );
-
-    MPI_CHK( mpi_read_string( &U, 16,
-        "36E139AEA55215609D2816998ED020BB" \
-        "BD96C37890F65171D948E9BC7CBAA4D9" \
-        "325D24D6A3C12710F10A09FA08AB87" ) );
-
-    if( verbose != 0 )
-        printf( "  MPI test #3 (exp_mod): " );
-
-    if( mpi_cmp_mpi( &X, &U ) != 0 )
-    {
-        if( verbose != 0 )
-            printf( "failed\n" );
-
-        ret = 1;
-        goto cleanup;
-    }
-
-    if( verbose != 0 )
-        printf( "passed\n" );
-
-    MPI_CHK( mpi_inv_mod( &X, &A, &N ) );
-
-    MPI_CHK( mpi_read_string( &U, 16,
-        "003A0AAEDD7E784FC07D8F9EC6E3BFD5" \
-        "C3DBA76456363A10869622EAC2DD84EC" \
-        "C5B8A74DAC4D09E03B5E0BE779F2DF61" ) );
-
-    if( verbose != 0 )
-        printf( "  MPI test #4 (inv_mod): " );
-
-    if( mpi_cmp_mpi( &X, &U ) != 0 )
-    {
-        if( verbose != 0 )
-            printf( "failed\n" );
-
-        ret = 1;
-        goto cleanup;
-    }
-
-    if( verbose != 0 )
-        printf( "passed\n" );
-
-    if( verbose != 0 )
-        printf( "  MPI test #5 (simple gcd): " );
-
-    for ( i = 0; i < GCD_PAIR_COUNT; i++)
-    {
-        MPI_CHK( mpi_lset( &X, gcd_pairs[i][0] ) );
-        MPI_CHK( mpi_lset( &Y, gcd_pairs[i][1] ) );
-
-        MPI_CHK( mpi_gcd( &A, &X, &Y ) );
-
-        if( mpi_cmp_int( &A, gcd_pairs[i][2] ) != 0 )
-        {
-            if( verbose != 0 )
-                printf( "failed at %d\n", i );
-
-            ret = 1;
-            goto cleanup;
-        }
-    }
-
-    if( verbose != 0 )
-        printf( "passed\n" );
-
-cleanup:
-
-    if( ret != 0 && verbose != 0 )
-        printf( "Unexpected error, return code = %08X\n", ret );
-
-    mpi_free( &A ); mpi_free( &E ); mpi_free( &N ); mpi_free( &X );
-    mpi_free( &Y ); mpi_free( &U ); mpi_free( &V );
-
-    if( verbose != 0 )
-        printf( "\n" );
-
-    return( ret );
-}
-
-#endif
-
-#endif
--- a/library/md.c
+++ b/library/md.c
@@ -27,294 +27,18 @@
  *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
 
-#include "polarssl/config.h"
-
-#if defined(POLARSSL_MD_C)
-
-#include "polarssl/md.h"
-#include "polarssl/md_wrap.h"
-
-#include <stdlib.h>
-
-#if defined(_MSC_VER) && !defined strcasecmp && !defined(EFIX64) && \
-    !defined(EFI32)
-#define strcasecmp  _stricmp
-#endif
-
-static const int supported_digests[] = {
-
-#if defined(POLARSSL_MD2_C)
-        POLARSSL_MD_MD2,
-#endif
-
-#if defined(POLARSSL_MD4_C)
-        POLARSSL_MD_MD4,
-#endif
-
-#if defined(POLARSSL_MD5_C)
-        POLARSSL_MD_MD5,
-#endif
-
-#if defined(POLARSSL_RIPEMD160_C)
-        POLARSSL_MD_RIPEMD160,
-#endif
-
-#if defined(POLARSSL_SHA1_C)
-        POLARSSL_MD_SHA1,
-#endif
-
-#if defined(POLARSSL_SHA256_C)
-        POLARSSL_MD_SHA224,
-        POLARSSL_MD_SHA256,
-#endif
-
-#if defined(POLARSSL_SHA512_C)
-        POLARSSL_MD_SHA384,
-        POLARSSL_MD_SHA512,
-#endif
-
-        0
-};
-
-const int *md_list( void )
-{
-    return supported_digests;
-}
-
-const md_info_t *md_info_from_string( const char *md_name )
-{
-    if( NULL == md_name )
-        return NULL;
-
-    /* Get the appropriate digest information */
-#if defined(POLARSSL_MD2_C)
-    if( !strcasecmp( "MD2", md_name ) )
-        return md_info_from_type( POLARSSL_MD_MD2 );
-#endif
-#if defined(POLARSSL_MD4_C)
-    if( !strcasecmp( "MD4", md_name ) )
-        return md_info_from_type( POLARSSL_MD_MD4 );
-#endif
-#if defined(POLARSSL_MD5_C)
-    if( !strcasecmp( "MD5", md_name ) )
-        return md_info_from_type( POLARSSL_MD_MD5 );
-#endif
-#if defined(POLARSSL_RIPEMD160_C)
-    if( !strcasecmp( "RIPEMD160", md_name ) )
-        return md_info_from_type( POLARSSL_MD_RIPEMD160 );
-#endif
-#if defined(POLARSSL_SHA1_C)
-    if( !strcasecmp( "SHA1", md_name ) || !strcasecmp( "SHA", md_name ) )
-        return md_info_from_type( POLARSSL_MD_SHA1 );
-#endif
-#if defined(POLARSSL_SHA256_C)
-    if( !strcasecmp( "SHA224", md_name ) )
-        return md_info_from_type( POLARSSL_MD_SHA224 );
-    if( !strcasecmp( "SHA256", md_name ) )
-        return md_info_from_type( POLARSSL_MD_SHA256 );
-#endif
-#if defined(POLARSSL_SHA512_C)
-    if( !strcasecmp( "SHA384", md_name ) )
-        return md_info_from_type( POLARSSL_MD_SHA384 );
-    if( !strcasecmp( "SHA512", md_name ) )
-        return md_info_from_type( POLARSSL_MD_SHA512 );
-#endif
-    return NULL;
-}
+#include "md.h"
+#include "md_wrap.h"
 
 const md_info_t *md_info_from_type( md_type_t md_type )
 {
     switch( md_type )
     {
-#if defined(POLARSSL_MD2_C)
-        case POLARSSL_MD_MD2:
-            return &md2_info;
-#endif
-#if defined(POLARSSL_MD4_C)
-        case POLARSSL_MD_MD4:
-            return &md4_info;
-#endif
-#if defined(POLARSSL_MD5_C)
-        case POLARSSL_MD_MD5:
-            return &md5_info;
-#endif
-#if defined(POLARSSL_RIPEMD160_C)
-        case POLARSSL_MD_RIPEMD160:
-            return &ripemd160_info;
-#endif
-#if defined(POLARSSL_SHA1_C)
-        case POLARSSL_MD_SHA1:
-            return &sha1_info;
-#endif
-#if defined(POLARSSL_SHA256_C)
-        case POLARSSL_MD_SHA224:
-            return &sha224_info;
         case POLARSSL_MD_SHA256:
             return &sha256_info;
-#endif
-#if defined(POLARSSL_SHA512_C)
-        case POLARSSL_MD_SHA384:
-            return &sha384_info;
-        case POLARSSL_MD_SHA512:
-            return &sha512_info;
-#endif
         default:
             return NULL;
     }
 }
 
-int md_init_ctx( md_context_t *ctx, const md_info_t *md_info )
-{
-    if( md_info == NULL || ctx == NULL )
-        return POLARSSL_ERR_MD_BAD_INPUT_DATA;
-
-    memset( ctx, 0, sizeof( md_context_t ) );
-
-    if( ( ctx->md_ctx = md_info->ctx_alloc_func() ) == NULL )
-        return POLARSSL_ERR_MD_ALLOC_FAILED;
-
-    ctx->md_info = md_info;
-
-    md_info->starts_func( ctx->md_ctx );
-
-    return 0;
-}
-
-int md_free_ctx( md_context_t *ctx )
-{
-    if( ctx == NULL || ctx->md_info == NULL )
-        return POLARSSL_ERR_MD_BAD_INPUT_DATA;
-
-    ctx->md_info->ctx_free_func( ctx->md_ctx );
-    ctx->md_ctx = NULL;
-
-    return 0;
-}
-
-int md_starts( md_context_t *ctx )
-{
-    if( ctx == NULL || ctx->md_info == NULL )
-        return POLARSSL_ERR_MD_BAD_INPUT_DATA;
-
-    ctx->md_info->starts_func( ctx->md_ctx );
-
-    return 0;
-}
-
-int md_update( md_context_t *ctx, const unsigned char *input, size_t ilen )
-{
-    if( ctx == NULL || ctx->md_info == NULL )
-        return POLARSSL_ERR_MD_BAD_INPUT_DATA;
-
-    ctx->md_info->update_func( ctx->md_ctx, input, ilen );
-
-    return 0;
-}
-
-int md_finish( md_context_t *ctx, unsigned char *output )
-{
-    if( ctx == NULL || ctx->md_info == NULL )
-        return POLARSSL_ERR_MD_BAD_INPUT_DATA;
-
-    ctx->md_info->finish_func( ctx->md_ctx, output );
-
-    return 0;
-}
-
-int md( const md_info_t *md_info, const unsigned char *input, size_t ilen,
-            unsigned char *output )
-{
-    if ( md_info == NULL )
-        return POLARSSL_ERR_MD_BAD_INPUT_DATA;
-
-    md_info->digest_func( input, ilen, output );
-
-    return 0;
-}
-
-int md_file( const md_info_t *md_info, const char *path, unsigned char *output )
-{
-#if defined(POLARSSL_FS_IO)
-    int ret;
-#endif
-
-    if( md_info == NULL )
-        return POLARSSL_ERR_MD_BAD_INPUT_DATA;
-
-#if defined(POLARSSL_FS_IO)
-    ret = md_info->file_func( path, output );
-    if( ret != 0 )
-        return( POLARSSL_ERR_MD_FILE_IO_ERROR + ret );
-
-    return( ret );
-#else
-    ((void) path);
-    ((void) output);
-
-    return POLARSSL_ERR_MD_FEATURE_UNAVAILABLE;
-#endif
-}
-
-int md_hmac_starts( md_context_t *ctx, const unsigned char *key, size_t keylen )
-{
-    if( ctx == NULL || ctx->md_info == NULL )
-        return POLARSSL_ERR_MD_BAD_INPUT_DATA;
-
-    ctx->md_info->hmac_starts_func( ctx->md_ctx, key, keylen);
-
-    return 0;
-}
-
-int md_hmac_update( md_context_t *ctx, const unsigned char *input, size_t ilen )
-{
-    if( ctx == NULL || ctx->md_info == NULL )
-        return POLARSSL_ERR_MD_BAD_INPUT_DATA;
-
-    ctx->md_info->hmac_update_func( ctx->md_ctx, input, ilen );
-
-    return 0;
-}
-
-int md_hmac_finish( md_context_t *ctx, unsigned char *output)
-{
-    if( ctx == NULL || ctx->md_info == NULL )
-        return POLARSSL_ERR_MD_BAD_INPUT_DATA;
-
-    ctx->md_info->hmac_finish_func( ctx->md_ctx, output);
-
-    return 0;
-}
-
-int md_hmac_reset( md_context_t *ctx )
-{
-    if( ctx == NULL || ctx->md_info == NULL )
-        return POLARSSL_ERR_MD_BAD_INPUT_DATA;
-
-    ctx->md_info->hmac_reset_func( ctx->md_ctx);
-
-    return 0;
-}
-
-int md_hmac( const md_info_t *md_info, const unsigned char *key, size_t keylen,
-                const unsigned char *input, size_t ilen,
-                unsigned char *output )
-{
-    if( md_info == NULL )
-        return POLARSSL_ERR_MD_BAD_INPUT_DATA;
-
-    md_info->hmac_func( key, keylen, input, ilen, output );
-
-    return 0;
-}
-
-int md_process( md_context_t *ctx, const unsigned char *data )
-{
-    if( ctx == NULL || ctx->md_info == NULL )
-        return POLARSSL_ERR_MD_BAD_INPUT_DATA;
-
-    ctx->md_info->process_func( ctx->md_ctx, data );
-
-    return 0;
-}
 
-#endif
--- a/library/md_wrap.c
+++ b/library/md_wrap.c
@@ -27,572 +27,13 @@
  *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
 
-#include "polarssl/config.h"
+#include "md_wrap.h"
+#include "sha256.h"
 
-#if defined(POLARSSL_MD_C)
-
-#include "polarssl/md_wrap.h"
-
-#if defined(POLARSSL_MD2_C)
-#include "polarssl/md2.h"
-#endif
-
-#if defined(POLARSSL_MD4_C)
-#include "polarssl/md4.h"
-#endif
-
-#if defined(POLARSSL_MD5_C)
-#include "polarssl/md5.h"
-#endif
-
-#if defined(POLARSSL_RIPEMD160_C)
-#include "polarssl/ripemd160.h"
-#endif
-
-#if defined(POLARSSL_SHA1_C)
-#include "polarssl/sha1.h"
-#endif
-
-#if defined(POLARSSL_SHA256_C)
-#include "polarssl/sha256.h"
-#endif
-
-#if defined(POLARSSL_SHA512_C)
-#include "polarssl/sha512.h"
-#endif
-
-#if defined(POLARSSL_MEMORY_C)
-#include "polarssl/memory.h"
-#else
-#define polarssl_malloc     malloc
-#define polarssl_free       free
-#endif
-
-#include <stdlib.h>
-
-#if defined(POLARSSL_MD2_C)
-
-static void md2_starts_wrap( void *ctx )
-{
-    md2_starts( (md2_context *) ctx );
-}
-
-static void md2_update_wrap( void *ctx, const unsigned char *input, size_t ilen )
-{
-    md2_update( (md2_context *) ctx, input, ilen );
-}
-
-static void md2_finish_wrap( void *ctx, unsigned char *output )
-{
-    md2_finish( (md2_context *) ctx, output );
-}
-
-static int md2_file_wrap( const char *path, unsigned char *output )
-{
-#if defined(POLARSSL_FS_IO)
-    return md2_file( path, output );
-#else
-    ((void) path);
-    ((void) output);
-    return POLARSSL_ERR_MD_FEATURE_UNAVAILABLE;
-#endif
-}
-
-static void md2_hmac_starts_wrap( void *ctx, const unsigned char *key, size_t keylen )
-{
-    md2_hmac_starts( (md2_context *) ctx, key, keylen );
-}
-
-static void md2_hmac_update_wrap( void *ctx, const unsigned char *input, size_t ilen )
-{
-    md2_hmac_update( (md2_context *) ctx, input, ilen );
-}
-
-static void md2_hmac_finish_wrap( void *ctx, unsigned char *output )
-{
-    md2_hmac_finish( (md2_context *) ctx, output );
-}
-
-static void md2_hmac_reset_wrap( void *ctx )
-{
-    md2_hmac_reset( (md2_context *) ctx );
-}
-
-static void * md2_ctx_alloc( void )
-{
-    return polarssl_malloc( sizeof( md2_context ) );
-}
-
-static void md2_ctx_free( void *ctx )
-{
-    polarssl_free( ctx );
-}
-
-static void md2_process_wrap( void *ctx, const unsigned char *data )
-{
-    ((void) data);
-
-    md2_process( (md2_context *) ctx );
-}
-
-const md_info_t md2_info = {
-    POLARSSL_MD_MD2,
-    "MD2",
-    16,
-    md2_starts_wrap,
-    md2_update_wrap,
-    md2_finish_wrap,
-    md2,
-    md2_file_wrap,
-    md2_hmac_starts_wrap,
-    md2_hmac_update_wrap,
-    md2_hmac_finish_wrap,
-    md2_hmac_reset_wrap,
-    md2_hmac,
-    md2_ctx_alloc,
-    md2_ctx_free,
-    md2_process_wrap,
-};
-
-#endif
-
-#if defined(POLARSSL_MD4_C)
-
-static void md4_starts_wrap( void *ctx )
-{
-    md4_starts( (md4_context *) ctx );
-}
-
-static void md4_update_wrap( void *ctx, const unsigned char *input, size_t ilen )
-{
-    md4_update( (md4_context *) ctx, input, ilen );
-}
-
-static void md4_finish_wrap( void *ctx, unsigned char *output )
-{
-    md4_finish( (md4_context *) ctx, output );
-}
-
-static int md4_file_wrap( const char *path, unsigned char *output )
-{
-#if defined(POLARSSL_FS_IO)
-    return md4_file( path, output );
-#else
-    ((void) path);
-    ((void) output);
-    return POLARSSL_ERR_MD_FEATURE_UNAVAILABLE;
-#endif
-}
-
-static void md4_hmac_starts_wrap( void *ctx, const unsigned char *key, size_t keylen )
-{
-    md4_hmac_starts( (md4_context *) ctx, key, keylen );
-}
-
-static void md4_hmac_update_wrap( void *ctx, const unsigned char *input, size_t ilen )
-{
-    md4_hmac_update( (md4_context *) ctx, input, ilen );
-}
-
-static void md4_hmac_finish_wrap( void *ctx, unsigned char *output )
-{
-    md4_hmac_finish( (md4_context *) ctx, output );
-}
-
-static void md4_hmac_reset_wrap( void *ctx )
-{
-    md4_hmac_reset( (md4_context *) ctx );
-}
-
-static void *md4_ctx_alloc( void )
-{
-    return polarssl_malloc( sizeof( md4_context ) );
-}
-
-static void md4_ctx_free( void *ctx )
-{
-    polarssl_free( ctx );
-}
-
-static void md4_process_wrap( void *ctx, const unsigned char *data )
-{
-    md4_process( (md4_context *) ctx, data );
-}
-
-const md_info_t md4_info = {
-    POLARSSL_MD_MD4,
-    "MD4",
-    16,
-    md4_starts_wrap,
-    md4_update_wrap,
-    md4_finish_wrap,
-    md4,
-    md4_file_wrap,
-    md4_hmac_starts_wrap,
-    md4_hmac_update_wrap,
-    md4_hmac_finish_wrap,
-    md4_hmac_reset_wrap,
-    md4_hmac,
-    md4_ctx_alloc,
-    md4_ctx_free,
-    md4_process_wrap,
-};
-
-#endif
-
-#if defined(POLARSSL_MD5_C)
-
-static void md5_starts_wrap( void *ctx )
-{
-    md5_starts( (md5_context *) ctx );
-}
-
-static void md5_update_wrap( void *ctx, const unsigned char *input, size_t ilen )
-{
-    md5_update( (md5_context *) ctx, input, ilen );
-}
-
-static void md5_finish_wrap( void *ctx, unsigned char *output )
-{
-    md5_finish( (md5_context *) ctx, output );
-}
-
-static int md5_file_wrap( const char *path, unsigned char *output )
-{
-#if defined(POLARSSL_FS_IO)
-    return md5_file( path, output );
-#else
-    ((void) path);
-    ((void) output);
-    return POLARSSL_ERR_MD_FEATURE_UNAVAILABLE;
-#endif
-}
-
-static void md5_hmac_starts_wrap( void *ctx, const unsigned char *key, size_t keylen )
-{
-    md5_hmac_starts( (md5_context *) ctx, key, keylen );
-}
-
-static void md5_hmac_update_wrap( void *ctx, const unsigned char *input, size_t ilen )
-{
-    md5_hmac_update( (md5_context *) ctx, input, ilen );
-}
-
-static void md5_hmac_finish_wrap( void *ctx, unsigned char *output )
-{
-    md5_hmac_finish( (md5_context *) ctx, output );
-}
-
-static void md5_hmac_reset_wrap( void *ctx )
-{
-    md5_hmac_reset( (md5_context *) ctx );
-}
-
-static void * md5_ctx_alloc( void )
-{
-    return polarssl_malloc( sizeof( md5_context ) );
-}
-
-static void md5_ctx_free( void *ctx )
-{
-    polarssl_free( ctx );
-}
-
-static void md5_process_wrap( void *ctx, const unsigned char *data )
-{
-    md5_process( (md5_context *) ctx, data );
-}
-
-const md_info_t md5_info = {
-    POLARSSL_MD_MD5,
-    "MD5",
-    16,
-    md5_starts_wrap,
-    md5_update_wrap,
-    md5_finish_wrap,
-    md5,
-    md5_file_wrap,
-    md5_hmac_starts_wrap,
-    md5_hmac_update_wrap,
-    md5_hmac_finish_wrap,
-    md5_hmac_reset_wrap,
-    md5_hmac,
-    md5_ctx_alloc,
-    md5_ctx_free,
-    md5_process_wrap,
-};
-
-#endif
-
-#if defined(POLARSSL_RIPEMD160_C)
-
-static void ripemd160_starts_wrap( void *ctx )
-{
-    ripemd160_starts( (ripemd160_context *) ctx );
-}
-
-static void ripemd160_update_wrap( void *ctx, const unsigned char *input, size_t ilen )
-{
-    ripemd160_update( (ripemd160_context *) ctx, input, ilen );
-}
-
-static void ripemd160_finish_wrap( void *ctx, unsigned char *output )
-{
-    ripemd160_finish( (ripemd160_context *) ctx, output );
-}
-
-static int ripemd160_file_wrap( const char *path, unsigned char *output )
-{
-#if defined(POLARSSL_FS_IO)
-    return ripemd160_file( path, output );
-#else
-    ((void) path);
-    ((void) output);
-    return POLARSSL_ERR_MD_FEATURE_UNAVAILABLE;
-#endif
-}
-
-static void ripemd160_hmac_starts_wrap( void *ctx, const unsigned char *key, size_t keylen )
-{
-    ripemd160_hmac_starts( (ripemd160_context *) ctx, key, keylen );
-}
-
-static void ripemd160_hmac_update_wrap( void *ctx, const unsigned char *input, size_t ilen )
-{
-    ripemd160_hmac_update( (ripemd160_context *) ctx, input, ilen );
-}
-
-static void ripemd160_hmac_finish_wrap( void *ctx, unsigned char *output )
-{
-    ripemd160_hmac_finish( (ripemd160_context *) ctx, output );
-}
-
-static void ripemd160_hmac_reset_wrap( void *ctx )
-{
-    ripemd160_hmac_reset( (ripemd160_context *) ctx );
-}
-
-static void * ripemd160_ctx_alloc( void )
-{
-    return polarssl_malloc( sizeof( ripemd160_context ) );
-}
-
-static void ripemd160_ctx_free( void *ctx )
-{
-    polarssl_free( ctx );
-}
-
-static void ripemd160_process_wrap( void *ctx, const unsigned char *data )
-{
-    ripemd160_process( (ripemd160_context *) ctx, data );
-}
-
-const md_info_t ripemd160_info = {
-    POLARSSL_MD_RIPEMD160,
-    "RIPEMD160",
-    20,
-    ripemd160_starts_wrap,
-    ripemd160_update_wrap,
-    ripemd160_finish_wrap,
-    ripemd160,
-    ripemd160_file_wrap,
-    ripemd160_hmac_starts_wrap,
-    ripemd160_hmac_update_wrap,
-    ripemd160_hmac_finish_wrap,
-    ripemd160_hmac_reset_wrap,
-    ripemd160_hmac,
-    ripemd160_ctx_alloc,
-    ripemd160_ctx_free,
-    ripemd160_process_wrap,
-};
-
-#endif
-
-#if defined(POLARSSL_SHA1_C)
-
-static void sha1_starts_wrap( void *ctx )
-{
-    sha1_starts( (sha1_context *) ctx );
-}
-
-static void sha1_update_wrap( void *ctx, const unsigned char *input, size_t ilen )
-{
-    sha1_update( (sha1_context *) ctx, input, ilen );
-}
-
-static void sha1_finish_wrap( void *ctx, unsigned char *output )
-{
-    sha1_finish( (sha1_context *) ctx, output );
-}
-
-static int sha1_file_wrap( const char *path, unsigned char *output )
-{
-#if defined(POLARSSL_FS_IO)
-    return sha1_file( path, output );
-#else
-    ((void) path);
-    ((void) output);
-    return POLARSSL_ERR_MD_FEATURE_UNAVAILABLE;
-#endif
-}
-
-static void sha1_hmac_starts_wrap( void *ctx, const unsigned char *key, size_t keylen )
-{
-    sha1_hmac_starts( (sha1_context *) ctx, key, keylen );
-}
-
-static void sha1_hmac_update_wrap( void *ctx, const unsigned char *input, size_t ilen )
-{
-    sha1_hmac_update( (sha1_context *) ctx, input, ilen );
-}
-
-static void sha1_hmac_finish_wrap( void *ctx, unsigned char *output )
-{
-    sha1_hmac_finish( (sha1_context *) ctx, output );
-}
-
-static void sha1_hmac_reset_wrap( void *ctx )
-{
-    sha1_hmac_reset( (sha1_context *) ctx );
-}
-
-static void * sha1_ctx_alloc( void )
-{
-    return polarssl_malloc( sizeof( sha1_context ) );
-}
-
-static void sha1_ctx_free( void *ctx )
-{
-    polarssl_free( ctx );
-}
-
-static void sha1_process_wrap( void *ctx, const unsigned char *data )
-{
-    sha1_process( (sha1_context *) ctx, data );
-}
-
-const md_info_t sha1_info = {
-    POLARSSL_MD_SHA1,
-    "SHA1",
-    20,
-    sha1_starts_wrap,
-    sha1_update_wrap,
-    sha1_finish_wrap,
-    sha1,
-    sha1_file_wrap,
-    sha1_hmac_starts_wrap,
-    sha1_hmac_update_wrap,
-    sha1_hmac_finish_wrap,
-    sha1_hmac_reset_wrap,
-    sha1_hmac,
-    sha1_ctx_alloc,
-    sha1_ctx_free,
-    sha1_process_wrap,
-};
-
-#endif
-
-/*
- * Wrappers for generic message digests
- */
-#if defined(POLARSSL_SHA256_C)
-
-static void sha224_starts_wrap( void *ctx )
-{
-    sha256_starts( (sha256_context *) ctx, 1 );
-}
-
-static void sha224_update_wrap( void *ctx, const unsigned char *input, size_t ilen )
-{
-    sha256_update( (sha256_context *) ctx, input, ilen );
-}
-
-static void sha224_finish_wrap( void *ctx, unsigned char *output )
-{
-    sha256_finish( (sha256_context *) ctx, output );
-}
-
-static void sha224_wrap( const unsigned char *input, size_t ilen,
-                    unsigned char *output )
-{
-    sha256( input, ilen, output, 1 );
-}
-
-static int sha224_file_wrap( const char *path, unsigned char *output )
-{
-#if defined(POLARSSL_FS_IO)
-    return sha256_file( path, output, 1 );
-#else
-    ((void) path);
-    ((void) output);
-    return POLARSSL_ERR_MD_FEATURE_UNAVAILABLE;
-#endif
-}
-
-static void sha224_hmac_starts_wrap( void *ctx, const unsigned char *key, size_t keylen )
-{
-    sha256_hmac_starts( (sha256_context *) ctx, key, keylen, 1 );
-}
-
-static void sha224_hmac_update_wrap( void *ctx, const unsigned char *input, size_t ilen )
-{
-    sha256_hmac_update( (sha256_context *) ctx, input, ilen );
-}
-
-static void sha224_hmac_finish_wrap( void *ctx, unsigned char *output )
-{
-    sha256_hmac_finish( (sha256_context *) ctx, output );
-}
-
-static void sha224_hmac_reset_wrap( void *ctx )
-{
-    sha256_hmac_reset( (sha256_context *) ctx );
-}
-
-static void sha224_hmac_wrap( const unsigned char *key, size_t keylen,
-        const unsigned char *input, size_t ilen,
-        unsigned char *output )
-{
-    sha256_hmac( key, keylen, input, ilen, output, 1 );
-}
-
-static void * sha224_ctx_alloc( void )
-{
-    return polarssl_malloc( sizeof( sha256_context ) );
-}
-
-static void sha224_ctx_free( void *ctx )
-{
-    polarssl_free( ctx );
-}
-
-static void sha224_process_wrap( void *ctx, const unsigned char *data )
-{
-    sha256_process( (sha256_context *) ctx, data );
-}
-
-const md_info_t sha224_info = {
-    POLARSSL_MD_SHA224,
-    "SHA224",
-    28,
-    sha224_starts_wrap,
-    sha224_update_wrap,
-    sha224_finish_wrap,
-    sha224_wrap,
-    sha224_file_wrap,
-    sha224_hmac_starts_wrap,
-    sha224_hmac_update_wrap,
-    sha224_hmac_finish_wrap,
-    sha224_hmac_reset_wrap,
-    sha224_hmac_wrap,
-    sha224_ctx_alloc,
-    sha224_ctx_free,
-    sha224_process_wrap,
-};
 
 static void sha256_starts_wrap( void *ctx )
 {
-    sha256_starts( (sha256_context *) ctx, 0 );
+    sha256_starts( (sha256_context *) ctx );
 }
 
 static void sha256_update_wrap( void *ctx, const unsigned char *input, size_t ilen )
@@ -651,12 +92,12 @@ static void sha256_hmac_wrap( const unsigned char *key, size_t keylen,
 
 static void * sha256_ctx_alloc( void )
 {
-    return polarssl_malloc( sizeof( sha256_context ) );
+    return malloc( sizeof( sha256_context ) );
 }
 
 static void sha256_ctx_free( void *ctx )
 {
-    polarssl_free( ctx );
+    free( ctx );
 }
 
 static void sha256_process_wrap( void *ctx, const unsigned char *data )
@@ -683,196 +124,3 @@ const md_info_t sha256_info = {
     sha256_process_wrap,
 };
 
-#endif
-
-#if defined(POLARSSL_SHA512_C)
-
-static void sha384_starts_wrap( void *ctx )
-{
-    sha512_starts( (sha512_context *) ctx, 1 );
-}
-
-static void sha384_update_wrap( void *ctx, const unsigned char *input, size_t ilen )
-{
-    sha512_update( (sha512_context *) ctx, input, ilen );
-}
-
-static void sha384_finish_wrap( void *ctx, unsigned char *output )
-{
-    sha512_finish( (sha512_context *) ctx, output );
-}
-
-static void sha384_wrap( const unsigned char *input, size_t ilen,
-                    unsigned char *output )
-{
-    sha512( input, ilen, output, 1 );
-}
-
-static int sha384_file_wrap( const char *path, unsigned char *output )
-{
-#if defined(POLARSSL_FS_IO)
-    return sha512_file( path, output, 1 );
-#else
-    ((void) path);
-    ((void) output);
-    return POLARSSL_ERR_MD_FEATURE_UNAVAILABLE;
-#endif
-}
-
-static void sha384_hmac_starts_wrap( void *ctx, const unsigned char *key, size_t keylen )
-{
-    sha512_hmac_starts( (sha512_context *) ctx, key, keylen, 1 );
-}
-
-static void sha384_hmac_update_wrap( void *ctx, const unsigned char *input, size_t ilen )
-{
-    sha512_hmac_update( (sha512_context *) ctx, input, ilen );
-}
-
-static void sha384_hmac_finish_wrap( void *ctx, unsigned char *output )
-{
-    sha512_hmac_finish( (sha512_context *) ctx, output );
-}
-
-static void sha384_hmac_reset_wrap( void *ctx )
-{
-    sha512_hmac_reset( (sha512_context *) ctx );
-}
-
-static void sha384_hmac_wrap( const unsigned char *key, size_t keylen,
-        const unsigned char *input, size_t ilen,
-        unsigned char *output )
-{
-    sha512_hmac( key, keylen, input, ilen, output, 1 );
-}
-
-static void * sha384_ctx_alloc( void )
-{
-    return polarssl_malloc( sizeof( sha512_context ) );
-}
-
-static void sha384_ctx_free( void *ctx )
-{
-    polarssl_free( ctx );
-}
-
-static void sha384_process_wrap( void *ctx, const unsigned char *data )
-{
-    sha512_process( (sha512_context *) ctx, data );
-}
-
-const md_info_t sha384_info = {
-    POLARSSL_MD_SHA384,
-    "SHA384",
-    48,
-    sha384_starts_wrap,
-    sha384_update_wrap,
-    sha384_finish_wrap,
-    sha384_wrap,
-    sha384_file_wrap,
-    sha384_hmac_starts_wrap,
-    sha384_hmac_update_wrap,
-    sha384_hmac_finish_wrap,
-    sha384_hmac_reset_wrap,
-    sha384_hmac_wrap,
-    sha384_ctx_alloc,
-    sha384_ctx_free,
-    sha384_process_wrap,
-};
-
-static void sha512_starts_wrap( void *ctx )
-{
-    sha512_starts( (sha512_context *) ctx, 0 );
-}
-
-static void sha512_update_wrap( void *ctx, const unsigned char *input, size_t ilen )
-{
-    sha512_update( (sha512_context *) ctx, input, ilen );
-}
-
-static void sha512_finish_wrap( void *ctx, unsigned char *output )
-{
-    sha512_finish( (sha512_context *) ctx, output );
-}
-
-static void sha512_wrap( const unsigned char *input, size_t ilen,
-                    unsigned char *output )
-{
-    sha512( input, ilen, output, 0 );
-}
-
-static int sha512_file_wrap( const char *path, unsigned char *output )
-{
-#if defined(POLARSSL_FS_IO)
-    return sha512_file( path, output, 0 );
-#else
-    ((void) path);
-    ((void) output);
-    return POLARSSL_ERR_MD_FEATURE_UNAVAILABLE;
-#endif
-}
-
-static void sha512_hmac_starts_wrap( void *ctx, const unsigned char *key, size_t keylen )
-{
-    sha512_hmac_starts( (sha512_context *) ctx, key, keylen, 0 );
-}
-
-static void sha512_hmac_update_wrap( void *ctx, const unsigned char *input, size_t ilen )
-{
-    sha512_hmac_update( (sha512_context *) ctx, input, ilen );
-}
-
-static void sha512_hmac_finish_wrap( void *ctx, unsigned char *output )
-{
-    sha512_hmac_finish( (sha512_context *) ctx, output );
-}
-
-static void sha512_hmac_reset_wrap( void *ctx )
-{
-    sha512_hmac_reset( (sha512_context *) ctx );
-}
-
-static void sha512_hmac_wrap( const unsigned char *key, size_t keylen,
-        const unsigned char *input, size_t ilen,
-        unsigned char *output )
-{
-    sha512_hmac( key, keylen, input, ilen, output, 0 );
-}
-
-static void * sha512_ctx_alloc( void )
-{
-    return polarssl_malloc( sizeof( sha512_context ) );
-}
-
-static void sha512_ctx_free( void *ctx )
-{
-    polarssl_free( ctx );
-}
-
-static void sha512_process_wrap( void *ctx, const unsigned char *data )
-{
-    sha512_process( (sha512_context *) ctx, data );
-}
-
-const md_info_t sha512_info = {
-    POLARSSL_MD_SHA512,
-    "SHA512",
-    64,
-    sha512_starts_wrap,
-    sha512_update_wrap,
-    sha512_finish_wrap,
-    sha512_wrap,
-    sha512_file_wrap,
-    sha512_hmac_starts_wrap,
-    sha512_hmac_update_wrap,
-    sha512_hmac_finish_wrap,
-    sha512_hmac_reset_wrap,
-    sha512_hmac_wrap,
-    sha512_ctx_alloc,
-    sha512_ctx_free,
-    sha512_process_wrap,
-};
-
-#endif
-
-#endif
--- a/library/oid.c
+++ b/library/oid.c
@@ -25,18 +25,9 @@
  *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
 
-#include "polarssl/config.h"
 
-#if defined(POLARSSL_OID_C)
-
-#include "polarssl/oid.h"
-#include "polarssl/rsa.h"
-
-#if defined(POLARSSL_X509_USE_C) || defined(POLARSSL_X509_CREATE_C)
-#include "polarssl/x509.h"
-#endif
-
-#include <stdio.h>
+#include "oid.h"
+#include "rsa.h"
 
 /*
  * Macro to automatically add the size of #define'd OIDs
@@ -78,34 +69,6 @@ int FN_NAME( const asn1_buf *oid, ATTR1_TYPE * ATTR1 )                  \
 }
 
 /*
- * Macro to generate a function for retrieving a single attribute from an
- * oid_descriptor_t wrapper.
- */
-#define FN_OID_GET_ATTR1(FN_NAME, TYPE_T, TYPE_NAME, ATTR1_TYPE, ATTR1) \
-int FN_NAME( const asn1_buf *oid, ATTR1_TYPE * ATTR1 )                  \
-{                                                                       \
-    const TYPE_T *data = oid_ ## TYPE_NAME ## _from_asn1( oid );        \
-    if( data == NULL ) return ( POLARSSL_ERR_OID_NOT_FOUND );           \
-    *ATTR1 = data->ATTR1;                                               \
-    return( 0 );                                                        \
-}
-
-/*
- * Macro to generate a function for retrieving two attributes from an
- * oid_descriptor_t wrapper.
- */
-#define FN_OID_GET_ATTR2(FN_NAME, TYPE_T, TYPE_NAME, ATTR1_TYPE, ATTR1,     \
-                         ATTR2_TYPE, ATTR2)                                 \
-int FN_NAME( const asn1_buf *oid, ATTR1_TYPE * ATTR1, ATTR2_TYPE * ATTR2 )  \
-{                                                                           \
-    const TYPE_T *data = oid_ ## TYPE_NAME ## _from_asn1( oid );            \
-    if( data == NULL ) return ( POLARSSL_ERR_OID_NOT_FOUND );               \
-    *ATTR1 = data->ATTR1;                                                   \
-    *ATTR2 = data->ATTR2;                                                   \
-    return( 0 );                                                            \
-}
-
-/*
  * Macro to generate a function for retrieving the OID based on a single
  * attribute from a oid_descriptor_t wrapper.
  */
@@ -125,349 +88,19 @@ int FN_NAME( ATTR1_TYPE ATTR1, const char **oid, size_t *olen )             \
 }
 
 /*
- * Macro to generate a function for retrieving the OID based on two
- * attributes from a oid_descriptor_t wrapper.
+ * Macro to generate a function for retrieving a single attribute from an
+ * oid_descriptor_t wrapper.
  */
-#define FN_OID_GET_OID_BY_ATTR2(FN_NAME, TYPE_T, LIST, ATTR1_TYPE, ATTR1,   \
-                                ATTR2_TYPE, ATTR2)                          \
-int FN_NAME( ATTR1_TYPE ATTR1, ATTR2_TYPE ATTR2, const char **oid ,         \
-             size_t *olen )                                                 \
-{                                                                           \
-    const TYPE_T *cur = LIST;                                               \
-    while( cur->descriptor.asn1 != NULL ) {                                 \
-        if( cur->ATTR1 == ATTR1 && cur->ATTR2 == ATTR2 ) {                  \
-            *oid = cur->descriptor.asn1;                                    \
-            *olen = cur->descriptor.asn1_len;                               \
-            return( 0 );                                                    \
-        }                                                                   \
-        cur++;                                                              \
-    }                                                                       \
-    return( POLARSSL_ERR_OID_NOT_FOUND );                                   \
+#define FN_OID_GET_ATTR1(FN_NAME, TYPE_T, TYPE_NAME, ATTR1_TYPE, ATTR1) \
+int FN_NAME( const asn1_buf *oid, ATTR1_TYPE * ATTR1 )                  \
+{                                                                       \
+    const TYPE_T *data = oid_ ## TYPE_NAME ## _from_asn1( oid );        \
+    if( data == NULL ) return ( POLARSSL_ERR_OID_NOT_FOUND );           \
+    *ATTR1 = data->ATTR1;                                               \
+    return( 0 );                                                        \
 }
 
 /*
- * For X520 attribute types
- */
-typedef struct {
-    oid_descriptor_t    descriptor;
-    const char          *short_name;
-} oid_x520_attr_t;
-
-static const oid_x520_attr_t oid_x520_attr_type[] =
-{
-    {
-        { ADD_LEN( OID_AT_CN ),          "id-at-commonName",               "Common Name" },
-        "CN",
-    },
-    {
-        { ADD_LEN( OID_AT_COUNTRY ),     "id-at-countryName",              "Country" },
-        "C",
-    },
-    {
-        { ADD_LEN( OID_AT_LOCALITY ),    "id-at-locality",                 "Locality" },
-        "L",
-    },
-    {
-        { ADD_LEN( OID_AT_STATE ),       "id-at-state",                    "State" },
-        "ST",
-    },
-    {
-        { ADD_LEN( OID_AT_ORGANIZATION ),"id-at-organizationName",         "Organization" },
-        "O",
-    },
-    {
-        { ADD_LEN( OID_AT_ORG_UNIT ),    "id-at-organizationalUnitName",   "Org Unit" },
-        "OU",
-    },
-    {
-        { ADD_LEN( OID_PKCS9_EMAIL ),    "emailAddress",                   "E-mail address" },
-        "emailAddress",
-    },
-    {
-        { ADD_LEN( OID_AT_SERIAL_NUMBER ),"id-at-serialNumber",            "Serial number" },
-        "serialNumber",
-    },
-    {
-        { ADD_LEN( OID_AT_POSTAL_ADDRESS ),"id-at-postalAddress",          "Postal address" },
-        "postalAddress",
-    },
-    {
-        { ADD_LEN( OID_AT_POSTAL_CODE ), "id-at-postalCode",               "Postal code" },
-        "postalCode",
-    },
-    {
-        { NULL, 0, NULL, NULL },
-        NULL,
-    }
-};
-
-FN_OID_TYPED_FROM_ASN1(oid_x520_attr_t, x520_attr, oid_x520_attr_type);
-FN_OID_GET_ATTR1(oid_get_attr_short_name, oid_x520_attr_t, x520_attr, const char *, short_name);
-
-#if defined(POLARSSL_X509_USE_C) || defined(POLARSSL_X509_CREATE_C)
-/*
- * For X509 extensions
- */
-typedef struct {
-    oid_descriptor_t    descriptor;
-    int                 ext_type;
-} oid_x509_ext_t;
-
-static const oid_x509_ext_t oid_x509_ext[] =
-{
-    {
-        { ADD_LEN( OID_BASIC_CONSTRAINTS ),    "id-ce-basicConstraints",   "Basic Constraints" },
-        EXT_BASIC_CONSTRAINTS,
-    },
-    {
-        { ADD_LEN( OID_KEY_USAGE ),            "id-ce-keyUsage",           "Key Usage" },
-        EXT_KEY_USAGE,
-    },
-    {
-        { ADD_LEN( OID_EXTENDED_KEY_USAGE ),   "id-ce-keyUsage",           "Extended Key Usage" },
-        EXT_EXTENDED_KEY_USAGE,
-    },
-    {
-        { ADD_LEN( OID_SUBJECT_ALT_NAME ),     "id-ce-subjectAltName",     "Subject Alt Name" },
-        EXT_SUBJECT_ALT_NAME,
-    },
-    {
-        { ADD_LEN( OID_NS_CERT_TYPE ),         "id-netscape-certtype",     "Netscape Certificate Type" },
-        EXT_NS_CERT_TYPE,
-    },
-    {
-        { NULL, 0, NULL, NULL },
-        0,
-    },
-};
-
-FN_OID_TYPED_FROM_ASN1(oid_x509_ext_t, x509_ext, oid_x509_ext);
-FN_OID_GET_ATTR1(oid_get_x509_ext_type, oid_x509_ext_t, x509_ext, int, ext_type);
-
-static const oid_descriptor_t oid_ext_key_usage[] =
-{
-    { ADD_LEN( OID_SERVER_AUTH ),      "id-kp-serverAuth",      "TLS Web Server Authentication" },
-    { ADD_LEN( OID_CLIENT_AUTH ),      "id-kp-clientAuth",      "TLS Web Client Authentication" },
-    { ADD_LEN( OID_CODE_SIGNING ),     "id-kp-codeSigning",     "Code Signing" },
-    { ADD_LEN( OID_EMAIL_PROTECTION ), "id-kp-emailProtection", "E-mail Protection" },
-    { ADD_LEN( OID_TIME_STAMPING ),    "id-kp-timeStamping",    "Time Stamping" },
-    { ADD_LEN( OID_OCSP_SIGNING ),     "id-kp-OCSPSigning",     "OCSP Signing" },
-    { NULL, 0, NULL, NULL },
-};
-
-FN_OID_TYPED_FROM_ASN1(oid_descriptor_t, ext_key_usage, oid_ext_key_usage);
-FN_OID_GET_ATTR1(oid_get_extended_key_usage, oid_descriptor_t, ext_key_usage, const char *, description);
-#endif /* POLARSSL_X509_USE_C || POLARSSL_X509_CREATE_C */
-
-#if defined(POLARSSL_MD_C)
-/*
- * For SignatureAlgorithmIdentifier
- */
-typedef struct {
-    oid_descriptor_t    descriptor;
-    md_type_t           md_alg;
-    pk_type_t           pk_alg;
-} oid_sig_alg_t;
-
-static const oid_sig_alg_t oid_sig_alg[] =
-{
-    {
-        { ADD_LEN( OID_PKCS1_MD2 ),        "md2WithRSAEncryption",     "RSA with MD2" },
-        POLARSSL_MD_MD2,      POLARSSL_PK_RSA,
-    },
-    {
-        { ADD_LEN( OID_PKCS1_MD4 ),        "md4WithRSAEncryption",     "RSA with MD4" },
-        POLARSSL_MD_MD4,      POLARSSL_PK_RSA,
-    },
-    {
-        { ADD_LEN( OID_PKCS1_MD5 ),        "md5WithRSAEncryption",     "RSA with MD5" },
-        POLARSSL_MD_MD5,      POLARSSL_PK_RSA,
-    },
-    {
-        { ADD_LEN( OID_PKCS1_SHA1 ),       "sha-1WithRSAEncryption",   "RSA with SHA1" },
-        POLARSSL_MD_SHA1,     POLARSSL_PK_RSA,
-    },
-    {
-        { ADD_LEN( OID_PKCS1_SHA224 ),     "sha224WithRSAEncryption",  "RSA with SHA-224" },
-        POLARSSL_MD_SHA224,   POLARSSL_PK_RSA,
-    },
-    {
-        { ADD_LEN( OID_PKCS1_SHA256 ),     "sha256WithRSAEncryption",  "RSA with SHA-256" },
-        POLARSSL_MD_SHA256,   POLARSSL_PK_RSA,
-    },
-    {
-        { ADD_LEN( OID_PKCS1_SHA384 ),     "sha384WithRSAEncryption",  "RSA with SHA-384" },
-        POLARSSL_MD_SHA384,   POLARSSL_PK_RSA,
-    },
-    {
-        { ADD_LEN( OID_PKCS1_SHA512 ),     "sha512WithRSAEncryption",  "RSA with SHA-512" },
-        POLARSSL_MD_SHA512,   POLARSSL_PK_RSA,
-    },
-    {
-        { ADD_LEN( OID_RSA_SHA_OBS ),      "sha-1WithRSAEncryption",   "RSA with SHA1" },
-        POLARSSL_MD_SHA1,     POLARSSL_PK_RSA,
-    },
-    {
-        { ADD_LEN( OID_ECDSA_SHA1 ),       "ecdsa-with-SHA1",      "ECDSA with SHA1" },
-        POLARSSL_MD_SHA1,     POLARSSL_PK_ECDSA,
-    },
-    {
-        { ADD_LEN( OID_ECDSA_SHA224 ),     "ecdsa-with-SHA224",    "ECDSA with SHA224" },
-        POLARSSL_MD_SHA224,   POLARSSL_PK_ECDSA,
-    },
-    {
-        { ADD_LEN( OID_ECDSA_SHA256 ),     "ecdsa-with-SHA256",    "ECDSA with SHA256" },
-        POLARSSL_MD_SHA256,   POLARSSL_PK_ECDSA,
-    },
-    {
-        { ADD_LEN( OID_ECDSA_SHA384 ),     "ecdsa-with-SHA384",    "ECDSA with SHA384" },
-        POLARSSL_MD_SHA384,   POLARSSL_PK_ECDSA,
-    },
-    {
-        { ADD_LEN( OID_ECDSA_SHA512 ),     "ecdsa-with-SHA512",    "ECDSA with SHA512" },
-        POLARSSL_MD_SHA512,   POLARSSL_PK_ECDSA,
-    },
-    {
-        { NULL, 0, NULL, NULL },
-        0, 0,
-    },
-};
-
-FN_OID_TYPED_FROM_ASN1(oid_sig_alg_t, sig_alg, oid_sig_alg);
-FN_OID_GET_DESCRIPTOR_ATTR1(oid_get_sig_alg_desc, oid_sig_alg_t, sig_alg, const char *, description);
-FN_OID_GET_ATTR2(oid_get_sig_alg, oid_sig_alg_t, sig_alg, md_type_t, md_alg, pk_type_t, pk_alg);
-FN_OID_GET_OID_BY_ATTR2(oid_get_oid_by_sig_alg, oid_sig_alg_t, oid_sig_alg, pk_type_t, pk_alg, md_type_t, md_alg);
-#endif /* POLARSSL_MD_C */
-
-/*
- * For PublicKeyInfo (PKCS1, RFC 5480)
- */
-typedef struct {
-    oid_descriptor_t    descriptor;
-    pk_type_t           pk_alg;
-} oid_pk_alg_t;
-
-static const oid_pk_alg_t oid_pk_alg[] =
-{
-    {
-        { ADD_LEN( OID_PKCS1_RSA ),      "rsaEncryption",   "RSA" },
-        POLARSSL_PK_RSA,
-    },
-    {
-        { ADD_LEN( OID_EC_ALG_UNRESTRICTED ),  "id-ecPublicKey",   "Generic EC key" },
-        POLARSSL_PK_ECKEY,
-    },
-    {
-        { ADD_LEN( OID_EC_ALG_ECDH ),          "id-ecDH",          "EC key for ECDH" },
-        POLARSSL_PK_ECKEY_DH,
-    },
-    {
-        { NULL, 0, NULL, NULL },
-        0,
-    },
-};
-
-FN_OID_TYPED_FROM_ASN1(oid_pk_alg_t, pk_alg, oid_pk_alg);
-FN_OID_GET_ATTR1(oid_get_pk_alg, oid_pk_alg_t, pk_alg, pk_type_t, pk_alg);
-FN_OID_GET_OID_BY_ATTR1(oid_get_oid_by_pk_alg, oid_pk_alg_t, oid_pk_alg, pk_type_t, pk_alg);
-
-#if defined(POLARSSL_ECP_C)
-/*
- * For namedCurve (RFC 5480)
- */
-typedef struct {
-    oid_descriptor_t    descriptor;
-    ecp_group_id        grp_id;
-} oid_ecp_grp_t;
-
-static const oid_ecp_grp_t oid_ecp_grp[] =
-{
-    {
-        { ADD_LEN( OID_EC_GRP_SECP192R1 ), "secp192r1",    "secp192r1" },
-        POLARSSL_ECP_DP_SECP192R1,
-    },
-    {
-        { ADD_LEN( OID_EC_GRP_SECP224R1 ), "secp224r1",    "secp224r1" },
-        POLARSSL_ECP_DP_SECP224R1,
-    },
-    {
-        { ADD_LEN( OID_EC_GRP_SECP256R1 ), "secp256r1",    "secp256r1" },
-        POLARSSL_ECP_DP_SECP256R1,
-    },
-    {
-        { ADD_LEN( OID_EC_GRP_SECP384R1 ), "secp384r1",    "secp384r1" },
-        POLARSSL_ECP_DP_SECP384R1,
-    },
-    {
-        { ADD_LEN( OID_EC_GRP_SECP521R1 ), "secp521r1",    "secp521r1" },
-        POLARSSL_ECP_DP_SECP521R1,
-    },
-    {
-        { ADD_LEN( OID_EC_GRP_SECP192K1 ), "secp192k1",    "secp192k1" },
-        POLARSSL_ECP_DP_SECP192K1,
-    },
-    {
-        { ADD_LEN( OID_EC_GRP_SECP224K1 ), "secp224k1",    "secp224k1" },
-        POLARSSL_ECP_DP_SECP224K1,
-    },
-    {
-        { ADD_LEN( OID_EC_GRP_SECP256K1 ), "secp256k1",    "secp256k1" },
-        POLARSSL_ECP_DP_SECP256K1,
-    },
-    {
-        { ADD_LEN( OID_EC_GRP_BP256R1 ),   "brainpoolP256r1","brainpool256r1" },
-        POLARSSL_ECP_DP_BP256R1,
-    },
-    {
-        { ADD_LEN( OID_EC_GRP_BP384R1 ),   "brainpoolP384r1","brainpool384r1" },
-        POLARSSL_ECP_DP_BP384R1,
-    },
-    {
-        { ADD_LEN( OID_EC_GRP_BP512R1 ),   "brainpoolP512r1","brainpool512r1" },
-        POLARSSL_ECP_DP_BP512R1,
-    },
-    {
-        { NULL, 0, NULL, NULL },
-        0,
-    },
-};
-
-FN_OID_TYPED_FROM_ASN1(oid_ecp_grp_t, grp_id, oid_ecp_grp);
-FN_OID_GET_ATTR1(oid_get_ec_grp, oid_ecp_grp_t, grp_id, ecp_group_id, grp_id);
-FN_OID_GET_OID_BY_ATTR1(oid_get_oid_by_ec_grp, oid_ecp_grp_t, oid_ecp_grp, ecp_group_id, grp_id);
-#endif /* POLARSSL_ECP_C */
-
-#if defined(POLARSSL_CIPHER_C)
-/*
- * For PKCS#5 PBES2 encryption algorithm
- */
-typedef struct {
-    oid_descriptor_t    descriptor;
-    cipher_type_t       cipher_alg;
-} oid_cipher_alg_t;
-
-static const oid_cipher_alg_t oid_cipher_alg[] =
-{
-    {
-        { ADD_LEN( OID_DES_CBC ),              "desCBC",       "DES-CBC" },
-        POLARSSL_CIPHER_DES_CBC,
-    },
-    {
-        { ADD_LEN( OID_DES_EDE3_CBC ),         "des-ede3-cbc", "DES-EDE3-CBC" },
-        POLARSSL_CIPHER_DES_EDE3_CBC,
-    },
-    {
-        { NULL, 0, NULL, NULL },
-        0,
-    },
-};
-
-FN_OID_TYPED_FROM_ASN1(oid_cipher_alg_t, cipher_alg, oid_cipher_alg);
-FN_OID_GET_ATTR1(oid_get_cipher_alg, oid_cipher_alg_t, cipher_alg, cipher_type_t, cipher_alg);
-#endif /* POLARSSL_CIPHER_C */
-
-#if defined(POLARSSL_MD_C)
-/*
  * For digestAlgorithm
  */
 typedef struct {
@@ -521,130 +154,4 @@ static const oid_md_alg_t oid_md_alg[] =
 
 FN_OID_TYPED_FROM_ASN1(oid_md_alg_t, md_alg, oid_md_alg);
 FN_OID_GET_ATTR1(oid_get_md_alg, oid_md_alg_t, md_alg, md_type_t, md_alg);
-FN_OID_GET_OID_BY_ATTR1(oid_get_oid_by_md, oid_md_alg_t, oid_md_alg, md_type_t, md_alg);
-#endif /* POLARSSL_MD_C */
-
-#if defined(POLARSSL_PKCS12_C)
-/*
- * For PKCS#12 PBEs
- */
-typedef struct {
-    oid_descriptor_t    descriptor;
-    md_type_t           md_alg;
-    cipher_type_t       cipher_alg;
-} oid_pkcs12_pbe_alg_t;
-
-static const oid_pkcs12_pbe_alg_t oid_pkcs12_pbe_alg[] =
-{
-    {
-        { ADD_LEN( OID_PKCS12_PBE_SHA1_DES3_EDE_CBC ), "pbeWithSHAAnd3-KeyTripleDES-CBC", "PBE with SHA1 and 3-Key 3DES" },
-        POLARSSL_MD_SHA1,      POLARSSL_CIPHER_DES_EDE3_CBC,
-    },
-    {
-        { ADD_LEN( OID_PKCS12_PBE_SHA1_DES2_EDE_CBC ), "pbeWithSHAAnd2-KeyTripleDES-CBC", "PBE with SHA1 and 2-Key 3DES" },
-        POLARSSL_MD_SHA1,      POLARSSL_CIPHER_DES_EDE_CBC,
-    },
-    {
-        { NULL, 0, NULL, NULL },
-        0, 0,
-    },
-};
-
-FN_OID_TYPED_FROM_ASN1(oid_pkcs12_pbe_alg_t, pkcs12_pbe_alg, oid_pkcs12_pbe_alg);
-FN_OID_GET_ATTR2(oid_get_pkcs12_pbe_alg, oid_pkcs12_pbe_alg_t, pkcs12_pbe_alg, md_type_t, md_alg, cipher_type_t, cipher_alg);
-#endif /* POLARSSL_PKCS12_C */
-
-#if defined(_MSC_VER) && !defined snprintf && !defined(EFIX64) && \
-    !defined(EFI32)
-#include <stdarg.h>
-
-#if !defined vsnprintf
-#define vsnprintf _vsnprintf
-#endif // vsnprintf
-
-/*
- * Windows _snprintf and _vsnprintf are not compatible to linux versions.
- * Result value is not size of buffer needed, but -1 if no fit is possible.
- *
- * This fuction tries to 'fix' this by at least suggesting enlarging the
- * size by 20.
- */
-static int compat_snprintf(char *str, size_t size, const char *format, ...)
-{
-    va_list ap;
-    int res = -1;
-
-    va_start( ap, format );
-
-    res = vsnprintf( str, size, format, ap );
-
-    va_end( ap );
-
-    // No quick fix possible
-    if ( res < 0 )
-        return( (int) size + 20 );
-
-    return res;
-}
-
-#define snprintf compat_snprintf
-#endif
-
-#define POLARSSL_ERR_DEBUG_BUF_TOO_SMALL    -2
-
-#define SAFE_SNPRINTF()                         \
-{                                               \
-    if( ret == -1 )                             \
-        return( -1 );                           \
-                                                \
-    if ( (unsigned int) ret > n ) {             \
-        p[n - 1] = '\0';                        \
-        return POLARSSL_ERR_DEBUG_BUF_TOO_SMALL;\
-    }                                           \
-                                                \
-    n -= (unsigned int) ret;                    \
-    p += (unsigned int) ret;                    \
-}
-
-/* Return the x.y.z.... style numeric string for the given OID */
-int oid_get_numeric_string( char *buf, size_t size,
-                            const asn1_buf *oid )
-{
-    int ret;
-    size_t i, n;
-    unsigned int value;
-    char *p;
-
-    p = buf;
-    n = size;
-
-    /* First byte contains first two dots */
-    if( oid->len > 0 )
-    {
-        ret = snprintf( p, n, "%d.%d", oid->p[0] / 40, oid->p[0] % 40 );
-        SAFE_SNPRINTF();
-    }
-
-    value = 0;
-    for( i = 1; i < oid->len; i++ )
-    {
-        /* Prevent overflow in value. */
-        if ( ( ( value << 7 ) >> 7 ) != value )
-            return( POLARSSL_ERR_DEBUG_BUF_TOO_SMALL );
-
-        value <<= 7;
-        value += oid->p[i] & 0x7F;
-
-        if( !( oid->p[i] & 0x80 ) )
-        {
-            /* Last byte */
-            ret = snprintf( p, n, ".%d", value );
-            SAFE_SNPRINTF();
-            value = 0;
-        }
-    }
-
-    return( (int) ( size - n ) );
-}
 
-#endif /* POLARSSL_OID_C */
--- a/library/rsa.c
+++ b/library/rsa.c
@@ -22,1173 +22,61 @@
  *  with this program; if not, write to the Free Software Foundation, Inc.,
  *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
-/*
- *  RSA was designed by Ron Rivest, Adi Shamir and Len Adleman.
- *
- *  http://theory.lcs.mit.edu/~rivest/rsapaper.pdf
- *  http://www.cacr.math.uwaterloo.ca/hac/about/chap8.pdf
- */
-
-#include "polarssl/config.h"
-
-#if defined(POLARSSL_RSA_C)
-
-#include "polarssl/rsa.h"
-#include "polarssl/oid.h"
-
-#if defined(POLARSSL_PKCS1_V21)
-#include "polarssl/md.h"
-#endif
-
-#include <stdlib.h>
-#include <stdio.h>
-
-/*
- * Initialize an RSA context
- */
-void rsa_init( rsa_context *ctx,
-               int padding,
-               int hash_id )
-{
-    memset( ctx, 0, sizeof( rsa_context ) );
-
-    ctx->padding = padding;
-    ctx->hash_id = hash_id;
-
-#if defined(POLARSSL_THREADING_C)
-    polarssl_mutex_init( &ctx->mutex );
-#endif
-}
-
-#if defined(POLARSSL_GENPRIME)
-
-/*
- * Generate an RSA keypair
- */
-int rsa_gen_key( rsa_context *ctx,
-                 int (*f_rng)(void *, unsigned char *, size_t),
-                 void *p_rng,
-                 unsigned int nbits, int exponent )
-{
-    int ret;
-    mpi P1, Q1, H, G;
-
-    if( f_rng == NULL || nbits < 128 || exponent < 3 )
-        return( POLARSSL_ERR_RSA_BAD_INPUT_DATA );
-
-    mpi_init( &P1 ); mpi_init( &Q1 ); mpi_init( &H ); mpi_init( &G );
-
-    /*
-     * find primes P and Q with Q < P so that:
-     * GCD( E, (P-1)*(Q-1) ) == 1
-     */
-    MPI_CHK( mpi_lset( &ctx->E, exponent ) );
-
-    do
-    {
-        MPI_CHK( mpi_gen_prime( &ctx->P, ( nbits + 1 ) >> 1, 0, 
-                                f_rng, p_rng ) );
-
-        MPI_CHK( mpi_gen_prime( &ctx->Q, ( nbits + 1 ) >> 1, 0,
-                                f_rng, p_rng ) );
-
-        if( mpi_cmp_mpi( &ctx->P, &ctx->Q ) < 0 )
-            mpi_swap( &ctx->P, &ctx->Q );
-
-        if( mpi_cmp_mpi( &ctx->P, &ctx->Q ) == 0 )
-            continue;
-
-        MPI_CHK( mpi_mul_mpi( &ctx->N, &ctx->P, &ctx->Q ) );
-        if( mpi_msb( &ctx->N ) != nbits )
-            continue;
-
-        MPI_CHK( mpi_sub_int( &P1, &ctx->P, 1 ) );
-        MPI_CHK( mpi_sub_int( &Q1, &ctx->Q, 1 ) );
-        MPI_CHK( mpi_mul_mpi( &H, &P1, &Q1 ) );
-        MPI_CHK( mpi_gcd( &G, &ctx->E, &H  ) );
-    }
-    while( mpi_cmp_int( &G, 1 ) != 0 );
-
-    /*
-     * D  = E^-1 mod ((P-1)*(Q-1))
-     * DP = D mod (P - 1)
-     * DQ = D mod (Q - 1)
-     * QP = Q^-1 mod P
-     */
-    MPI_CHK( mpi_inv_mod( &ctx->D , &ctx->E, &H  ) );
-    MPI_CHK( mpi_mod_mpi( &ctx->DP, &ctx->D, &P1 ) );
-    MPI_CHK( mpi_mod_mpi( &ctx->DQ, &ctx->D, &Q1 ) );
-    MPI_CHK( mpi_inv_mod( &ctx->QP, &ctx->Q, &ctx->P ) );
-
-    ctx->len = ( mpi_msb( &ctx->N ) + 7 ) >> 3;
-
-cleanup:
-
-    mpi_free( &P1 ); mpi_free( &Q1 ); mpi_free( &H ); mpi_free( &G );
-
-    if( ret != 0 )
-    {
-        rsa_free( ctx );
-        return( POLARSSL_ERR_RSA_KEY_GEN_FAILED + ret );
-    }
-
-    return( 0 );
-}
-
-#endif
-
-/*
- * Check a public RSA key
- */
-int rsa_check_pubkey( const rsa_context *ctx )
-{
-    if( !ctx->N.p || !ctx->E.p )
-        return( POLARSSL_ERR_RSA_KEY_CHECK_FAILED );
-
-    if( ( ctx->N.p[0] & 1 ) == 0 ||
-        ( ctx->E.p[0] & 1 ) == 0 )
-        return( POLARSSL_ERR_RSA_KEY_CHECK_FAILED );
-
-    if( mpi_msb( &ctx->N ) < 128 ||
-        mpi_msb( &ctx->N ) > POLARSSL_MPI_MAX_BITS )
-        return( POLARSSL_ERR_RSA_KEY_CHECK_FAILED );
-
-    if( mpi_msb( &ctx->E ) < 2 ||
-        mpi_msb( &ctx->E ) > 64 )
-        return( POLARSSL_ERR_RSA_KEY_CHECK_FAILED );
-
-    return( 0 );
-}
-
-/*
- * Check a private RSA key
- */
-int rsa_check_privkey( const rsa_context *ctx )
-{
-    int ret;
-    mpi PQ, DE, P1, Q1, H, I, G, G2, L1, L2, DP, DQ, QP;
-
-    if( ( ret = rsa_check_pubkey( ctx ) ) != 0 )
-        return( ret );
-
-    if( !ctx->P.p || !ctx->Q.p || !ctx->D.p )
-        return( POLARSSL_ERR_RSA_KEY_CHECK_FAILED );
-
-    mpi_init( &PQ ); mpi_init( &DE ); mpi_init( &P1 ); mpi_init( &Q1 );
-    mpi_init( &H  ); mpi_init( &I  ); mpi_init( &G  ); mpi_init( &G2 );
-    mpi_init( &L1 ); mpi_init( &L2 ); mpi_init( &DP ); mpi_init( &DQ );
-    mpi_init( &QP );
-
-    MPI_CHK( mpi_mul_mpi( &PQ, &ctx->P, &ctx->Q ) );
-    MPI_CHK( mpi_mul_mpi( &DE, &ctx->D, &ctx->E ) );
-    MPI_CHK( mpi_sub_int( &P1, &ctx->P, 1 ) );
-    MPI_CHK( mpi_sub_int( &Q1, &ctx->Q, 1 ) );
-    MPI_CHK( mpi_mul_mpi( &H, &P1, &Q1 ) );
-    MPI_CHK( mpi_gcd( &G, &ctx->E, &H  ) );
-
-    MPI_CHK( mpi_gcd( &G2, &P1, &Q1 ) );
-    MPI_CHK( mpi_div_mpi( &L1, &L2, &H, &G2 ) );
-    MPI_CHK( mpi_mod_mpi( &I, &DE, &L1  ) );
-
-    MPI_CHK( mpi_mod_mpi( &DP, &ctx->D, &P1 ) );
-    MPI_CHK( mpi_mod_mpi( &DQ, &ctx->D, &Q1 ) );
-    MPI_CHK( mpi_inv_mod( &QP, &ctx->Q, &ctx->P ) );
-    /*
-     * Check for a valid PKCS1v2 private key
-     */
-    if( mpi_cmp_mpi( &PQ, &ctx->N ) != 0 ||
-        mpi_cmp_mpi( &DP, &ctx->DP ) != 0 ||
-        mpi_cmp_mpi( &DQ, &ctx->DQ ) != 0 ||
-        mpi_cmp_mpi( &QP, &ctx->QP ) != 0 ||
-        mpi_cmp_int( &L2, 0 ) != 0 ||
-        mpi_cmp_int( &I, 1 ) != 0 ||
-        mpi_cmp_int( &G, 1 ) != 0 )
-    {
-        ret = POLARSSL_ERR_RSA_KEY_CHECK_FAILED;
-    }
-
-cleanup:
-    mpi_free( &PQ ); mpi_free( &DE ); mpi_free( &P1 ); mpi_free( &Q1 );
-    mpi_free( &H  ); mpi_free( &I  ); mpi_free( &G  ); mpi_free( &G2 );
-    mpi_free( &L1 ); mpi_free( &L2 ); mpi_free( &DP ); mpi_free( &DQ );
-    mpi_free( &QP );
-
-    if( ret == POLARSSL_ERR_RSA_KEY_CHECK_FAILED )
-        return( ret );
-
-    if( ret != 0 )
-        return( POLARSSL_ERR_RSA_KEY_CHECK_FAILED + ret );
-
-    return( 0 );
-}
-
-/*
- * Do an RSA public key operation
- */
-int rsa_public( rsa_context *ctx,
-                const unsigned char *input,
-                unsigned char *output )
-{
-    int ret;
-    size_t olen;
-    mpi T;
-
-    mpi_init( &T );
-
-    MPI_CHK( mpi_read_binary( &T, input, ctx->len ) );
-
-    if( mpi_cmp_mpi( &T, &ctx->N ) >= 0 )
-    {
-        mpi_free( &T );
-        return( POLARSSL_ERR_RSA_BAD_INPUT_DATA );
-    }
-
-    olen = ctx->len;
-    MPI_CHK( mpi_exp_mod( &T, &T, &ctx->E, &ctx->N, &ctx->RN ) );
-    MPI_CHK( mpi_write_binary( &T, output, olen ) );
-
-cleanup:
-
-    mpi_free( &T );
-
-    if( ret != 0 )
-        return( POLARSSL_ERR_RSA_PUBLIC_FAILED + ret );
-
-    return( 0 );
-}
-
-#if !defined(POLARSSL_RSA_NO_CRT)
-/*
- * Generate or update blinding values, see section 10 of:
- *  KOCHER, Paul C. Timing attacks on implementations of Diffie-Hellman, RSA,
- *  DSS, and other systems. In : Advances in Cryptology—CRYPTO’96. Springer
- *  Berlin Heidelberg, 1996. p. 104-113.
- */
-static int rsa_prepare_blinding( rsa_context *ctx, mpi *Vi, mpi *Vf,
-                 int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )
-{
-    int ret, count = 0;
-
-#if defined(POLARSSL_THREADING_C)
-    polarssl_mutex_lock( &ctx->mutex );
-#endif
-
-    if( ctx->Vf.p != NULL )
-    {
-        /* We already have blinding values, just update them by squaring */
-        MPI_CHK( mpi_mul_mpi( &ctx->Vi, &ctx->Vi, &ctx->Vi ) );
-        MPI_CHK( mpi_mod_mpi( &ctx->Vi, &ctx->Vi, &ctx->N ) );
-        MPI_CHK( mpi_mul_mpi( &ctx->Vf, &ctx->Vf, &ctx->Vf ) );
-        MPI_CHK( mpi_mod_mpi( &ctx->Vf, &ctx->Vf, &ctx->N ) );
-
-        goto done;
-    }
-
-    /* Unblinding value: Vf = random number, invertible mod N */
-    do {
-        if( count++ > 10 )
-            return( POLARSSL_ERR_RSA_RNG_FAILED );
-
-        MPI_CHK( mpi_fill_random( &ctx->Vf, ctx->len - 1, f_rng, p_rng ) );
-        MPI_CHK( mpi_gcd( &ctx->Vi, &ctx->Vf, &ctx->N ) );
-    } while( mpi_cmp_int( &ctx->Vi, 1 ) != 0 );
-
-    /* Blinding value: Vi =  Vf^(-e) mod N */
-    MPI_CHK( mpi_inv_mod( &ctx->Vi, &ctx->Vf, &ctx->N ) );
-    MPI_CHK( mpi_exp_mod( &ctx->Vi, &ctx->Vi, &ctx->E, &ctx->N, &ctx->RN ) );
-
-done:
-    if( Vi != &ctx->Vi )
-    {
-        MPI_CHK( mpi_copy( Vi, &ctx->Vi ) );
-        MPI_CHK( mpi_copy( Vf, &ctx->Vf ) );
-    }
-
-cleanup:
-#if defined(POLARSSL_THREADING_C)
-    polarssl_mutex_unlock( &ctx->mutex );
-#endif
-
-    return( ret );
-}
-#endif
-
-/*
- * Do an RSA private key operation
- */
-int rsa_private( rsa_context *ctx,
-                 int (*f_rng)(void *, unsigned char *, size_t),
-                 void *p_rng,
-                 const unsigned char *input,
-                 unsigned char *output )
-{
-    int ret;
-    size_t olen;
-    mpi T, T1, T2;
-#if !defined(POLARSSL_RSA_NO_CRT)
-    mpi *Vi, *Vf;
-
-    /*
-     * When using the Chinese Remainder Theorem, we use blinding values.
-     * Without threading, we just read them directly from the context,
-     * otherwise we make a local copy in order to reduce locking contention.
-     */
-#if defined(POLARSSL_THREADING_C)
-    mpi Vi_copy, Vf_copy;
-
-    mpi_init( &Vi_copy ); mpi_init( &Vf_copy );
-    Vi = &Vi_copy;
-    Vf = &Vf_copy;
-#else
-    Vi = &ctx->Vi;
-    Vf = &ctx->Vf;
-#endif
-#endif
-
-    mpi_init( &T ); mpi_init( &T1 ); mpi_init( &T2 );
-
-    MPI_CHK( mpi_read_binary( &T, input, ctx->len ) );
-    if( mpi_cmp_mpi( &T, &ctx->N ) >= 0 )
-    {
-        mpi_free( &T );
-        return( POLARSSL_ERR_RSA_BAD_INPUT_DATA );
-    }
-
-#if defined(POLARSSL_RSA_NO_CRT)
-    ((void) f_rng);
-    ((void) p_rng);
-    MPI_CHK( mpi_exp_mod( &T, &T, &ctx->D, &ctx->N, &ctx->RN ) );
-#else
-    if( f_rng != NULL )
-    {
-        /*
-         * Blinding
-         * T = T * Vi mod N
-         */
-        MPI_CHK( rsa_prepare_blinding( ctx, Vi, Vf, f_rng, p_rng ) );
-        MPI_CHK( mpi_mul_mpi( &T, &T, Vi ) );
-        MPI_CHK( mpi_mod_mpi( &T, &T, &ctx->N ) );
-    }
-
-    /*
-     * faster decryption using the CRT
-     *
-     * T1 = input ^ dP mod P
-     * T2 = input ^ dQ mod Q
-     */
-    MPI_CHK( mpi_exp_mod( &T1, &T, &ctx->DP, &ctx->P, &ctx->RP ) );
-    MPI_CHK( mpi_exp_mod( &T2, &T, &ctx->DQ, &ctx->Q, &ctx->RQ ) );
-
-    /*
-     * T = (T1 - T2) * (Q^-1 mod P) mod P
-     */
-    MPI_CHK( mpi_sub_mpi( &T, &T1, &T2 ) );
-    MPI_CHK( mpi_mul_mpi( &T1, &T, &ctx->QP ) );
-    MPI_CHK( mpi_mod_mpi( &T, &T1, &ctx->P ) );
-
-    /*
-     * T = T2 + T * Q
-     */
-    MPI_CHK( mpi_mul_mpi( &T1, &T, &ctx->Q ) );
-    MPI_CHK( mpi_add_mpi( &T, &T2, &T1 ) );
-
-    if( f_rng != NULL )
-    {
-        /*
-         * Unblind
-         * T = T * Vf mod N
-         */
-        MPI_CHK( mpi_mul_mpi( &T, &T, Vf ) );
-        MPI_CHK( mpi_mod_mpi( &T, &T, &ctx->N ) );
-    }
-#endif
-
-    olen = ctx->len;
-    MPI_CHK( mpi_write_binary( &T, output, olen ) );
-
-cleanup:
-    mpi_free( &T ); mpi_free( &T1 ); mpi_free( &T2 );
-#if !defined(POLARSSL_RSA_NO_CRT) && defined(POLARSSL_THREADING_C)
-    mpi_free( &Vi_copy ); mpi_free( &Vf_copy );
-#endif
-
-    if( ret != 0 )
-        return( POLARSSL_ERR_RSA_PRIVATE_FAILED + ret );
-
-    return( 0 );
-}
-
-#if defined(POLARSSL_PKCS1_V21)
-/**
- * Generate and apply the MGF1 operation (from PKCS#1 v2.1) to a buffer.
- *
- * \param dst       buffer to mask
- * \param dlen      length of destination buffer
- * \param src       source of the mask generation
- * \param slen      length of the source buffer
- * \param md_ctx    message digest context to use
- */
-static void mgf_mask( unsigned char *dst, size_t dlen, unsigned char *src,
-                      size_t slen, md_context_t *md_ctx )
-{
-    unsigned char mask[POLARSSL_MD_MAX_SIZE];
-    unsigned char counter[4];
-    unsigned char *p;
-    unsigned int hlen;
-    size_t i, use_len;
-
-    memset( mask, 0, POLARSSL_MD_MAX_SIZE );
-    memset( counter, 0, 4 );
-
-    hlen = md_ctx->md_info->size;
-
-    // Generate and apply dbMask
-    //
-    p = dst;
-
-    while( dlen > 0 )
-    {
-        use_len = hlen;
-        if( dlen < hlen )
-            use_len = dlen;
-
-        md_starts( md_ctx );
-        md_update( md_ctx, src, slen );
-        md_update( md_ctx, counter, 4 );
-        md_finish( md_ctx, mask );
-
-        for( i = 0; i < use_len; ++i )
-            *p++ ^= mask[i];
-
-        counter[3]++;
-
-        dlen -= use_len;
-    }
-}
-#endif
-
-#if defined(POLARSSL_PKCS1_V21)
-/*
- * Implementation of the PKCS#1 v2.1 RSAES-OAEP-ENCRYPT function
- */
-int rsa_rsaes_oaep_encrypt( rsa_context *ctx,
-                            int (*f_rng)(void *, unsigned char *, size_t),
-                            void *p_rng,
-                            int mode,
-                            const unsigned char *label, size_t label_len,
-                            size_t ilen,
-                            const unsigned char *input,
-                            unsigned char *output )
-{
-    size_t olen;
-    int ret;
-    unsigned char *p = output;
-    unsigned int hlen;
-    const md_info_t *md_info;
-    md_context_t md_ctx;
-
-    if( ctx->padding != RSA_PKCS_V21 || f_rng == NULL )
-        return( POLARSSL_ERR_RSA_BAD_INPUT_DATA );
-
-    md_info = md_info_from_type( ctx->hash_id );
-    if( md_info == NULL )
-        return( POLARSSL_ERR_RSA_BAD_INPUT_DATA );
-
-    olen = ctx->len;
-    hlen = md_get_size( md_info );
-
-    if( olen < ilen + 2 * hlen + 2 || f_rng == NULL )
-        return( POLARSSL_ERR_RSA_BAD_INPUT_DATA );
-
-    memset( output, 0, olen );
-
-    *p++ = 0;
-
-    // Generate a random octet string seed
-    //
-    if( ( ret = f_rng( p_rng, p, hlen ) ) != 0 )
-        return( POLARSSL_ERR_RSA_RNG_FAILED + ret );
-
-    p += hlen;
-
-    // Construct DB
-    //
-    md( md_info, label, label_len, p );
-    p += hlen;
-    p += olen - 2 * hlen - 2 - ilen;
-    *p++ = 1;
-    memcpy( p, input, ilen );
-
-    md_init_ctx( &md_ctx, md_info );
-
-    // maskedDB: Apply dbMask to DB
-    //
-    mgf_mask( output + hlen + 1, olen - hlen - 1, output + 1, hlen,
-               &md_ctx );
-
-    // maskedSeed: Apply seedMask to seed
-    //
-    mgf_mask( output + 1, hlen, output + hlen + 1, olen - hlen - 1,
-               &md_ctx );
-
-    md_free_ctx( &md_ctx );
-
-    return( ( mode == RSA_PUBLIC )
-            ? rsa_public(  ctx, output, output )
-            : rsa_private( ctx, f_rng, p_rng, output, output ) );
-}
-#endif /* POLARSSL_PKCS1_V21 */
-
-#if defined(POLARSSL_PKCS1_V15)
-/*
- * Implementation of the PKCS#1 v2.1 RSAES-PKCS1-V1_5-ENCRYPT function
- */
-int rsa_rsaes_pkcs1_v15_encrypt( rsa_context *ctx,
-                                 int (*f_rng)(void *, unsigned char *, size_t),
-                                 void *p_rng,
-                                 int mode, size_t ilen,
-                                 const unsigned char *input,
-                                 unsigned char *output )
-{
-    size_t nb_pad, olen;
-    int ret;
-    unsigned char *p = output;
-
-    if( ctx->padding != RSA_PKCS_V15 || f_rng == NULL )
-        return( POLARSSL_ERR_RSA_BAD_INPUT_DATA );
-
-    olen = ctx->len;
-
-    if( olen < ilen + 11 )
-        return( POLARSSL_ERR_RSA_BAD_INPUT_DATA );
-
-    nb_pad = olen - 3 - ilen;
-
-    *p++ = 0;
-    if( mode == RSA_PUBLIC )
-    {
-        *p++ = RSA_CRYPT;
-
-        while( nb_pad-- > 0 )
-        {
-            int rng_dl = 100;
-
-            do {
-                ret = f_rng( p_rng, p, 1 );
-            } while( *p == 0 && --rng_dl && ret == 0 );
-
-            // Check if RNG failed to generate data
-            //
-            if( rng_dl == 0 || ret != 0)
-                return POLARSSL_ERR_RSA_RNG_FAILED + ret;
-
-            p++;
-        }
-    }
-    else
-    {
-        *p++ = RSA_SIGN;
-
-        while( nb_pad-- > 0 )
-            *p++ = 0xFF;
-    }
-
-    *p++ = 0;
-    memcpy( p, input, ilen );
-
-    return( ( mode == RSA_PUBLIC )
-            ? rsa_public(  ctx, output, output )
-            : rsa_private( ctx, f_rng, p_rng, output, output ) );
-}
-#endif /* POLARSSL_PKCS1_V15 */
-
-/*
- * Add the message padding, then do an RSA operation
- */
-int rsa_pkcs1_encrypt( rsa_context *ctx,
-                       int (*f_rng)(void *, unsigned char *, size_t),
-                       void *p_rng,
-                       int mode, size_t ilen,
-                       const unsigned char *input,
-                       unsigned char *output )
-{
-    switch( ctx->padding )
-    {
-#if defined(POLARSSL_PKCS1_V15)
-        case RSA_PKCS_V15:
-            return rsa_rsaes_pkcs1_v15_encrypt( ctx, f_rng, p_rng, mode, ilen,
-                                                input, output );
-#endif
-
-#if defined(POLARSSL_PKCS1_V21)
-        case RSA_PKCS_V21:
-            return rsa_rsaes_oaep_encrypt( ctx, f_rng, p_rng, mode, NULL, 0,
-                                           ilen, input, output );
-#endif
-
-        default:
-            return( POLARSSL_ERR_RSA_INVALID_PADDING );
-    }
-}
-
-#if defined(POLARSSL_PKCS1_V21)
-/*
- * Implementation of the PKCS#1 v2.1 RSAES-OAEP-DECRYPT function
- */
-int rsa_rsaes_oaep_decrypt( rsa_context *ctx,
-                            int (*f_rng)(void *, unsigned char *, size_t),
-                            void *p_rng,
-                            int mode,
-                            const unsigned char *label, size_t label_len,
-                            size_t *olen,
-                            const unsigned char *input,
-                            unsigned char *output,
-                            size_t output_max_len )
-{
-    int ret;
-    size_t ilen, i, pad_len;
-    unsigned char *p, bad, pad_done;
-    unsigned char buf[POLARSSL_MPI_MAX_SIZE];
-    unsigned char lhash[POLARSSL_MD_MAX_SIZE];
-    unsigned int hlen;
-    const md_info_t *md_info;
-    md_context_t md_ctx;
-
-    /*
-     * Parameters sanity checks
-     */
-    if( ctx->padding != RSA_PKCS_V21 )
-        return( POLARSSL_ERR_RSA_BAD_INPUT_DATA );
-
-    ilen = ctx->len;
-
-    if( ilen < 16 || ilen > sizeof( buf ) )
-        return( POLARSSL_ERR_RSA_BAD_INPUT_DATA );
-
-    md_info = md_info_from_type( ctx->hash_id );
-    if( md_info == NULL )
-        return( POLARSSL_ERR_RSA_BAD_INPUT_DATA );
-
-    /*
-     * RSA operation
-     */
-    ret = ( mode == RSA_PUBLIC )
-          ? rsa_public(  ctx, input, buf )
-          : rsa_private( ctx, f_rng, p_rng, input, buf );
-
-    if( ret != 0 )
-        return( ret );
-
-    /*
-     * Unmask data and generate lHash
-     */
-    hlen = md_get_size( md_info );
-
-    md_init_ctx( &md_ctx, md_info );
-
-    /* Generate lHash */
-    md( md_info, label, label_len, lhash );
-
-    /* seed: Apply seedMask to maskedSeed */
-    mgf_mask( buf + 1, hlen, buf + hlen + 1, ilen - hlen - 1,
-               &md_ctx );
-
-    /* DB: Apply dbMask to maskedDB */
-    mgf_mask( buf + hlen + 1, ilen - hlen - 1, buf + 1, hlen,
-               &md_ctx );
-
-    md_free_ctx( &md_ctx );
-
-    /*
-     * Check contents, in "constant-time"
-     */
-    p = buf;
-    bad = 0;
-
-    bad |= *p++; /* First byte must be 0 */
-
-    p += hlen; /* Skip seed */
-
-    /* Check lHash */
-    for( i = 0; i < hlen; i++ )
-        bad |= lhash[i] ^ *p++;
-
-    /* Get zero-padding len, but always read till end of buffer
-     * (minus one, for the 01 byte) */
-    pad_len = 0;
-    pad_done = 0;
-    for( i = 0; i < ilen - 2 * hlen - 2; i++ )
-    {
-        pad_done |= p[i];
-        pad_len += ( pad_done == 0 );
-    }
-
-    p += pad_len;
-    bad |= *p++ ^ 0x01;
-
-    /*
-     * The only information "leaked" is whether the padding was correct or not
-     * (eg, no data is copied if it was not correct). This meets the
-     * recommendations in PKCS#1 v2.2: an opponent cannot distinguish between
-     * the different error conditions.
-     */
-    if( bad != 0 )
-        return( POLARSSL_ERR_RSA_INVALID_PADDING );
-
-    if (ilen - (p - buf) > output_max_len)
-        return( POLARSSL_ERR_RSA_OUTPUT_TOO_LARGE );
-
-    *olen = ilen - (p - buf);
-    memcpy( output, p, *olen );
-
-    return( 0 );
-}
-#endif /* POLARSSL_PKCS1_V21 */
-
-#if defined(POLARSSL_PKCS1_V15)
-/*
- * Implementation of the PKCS#1 v2.1 RSAES-PKCS1-V1_5-DECRYPT function
- */
-int rsa_rsaes_pkcs1_v15_decrypt( rsa_context *ctx,
-                                 int (*f_rng)(void *, unsigned char *, size_t),
-                                 void *p_rng,
-                                 int mode, size_t *olen,
-                                 const unsigned char *input,
-                                 unsigned char *output,
-                                 size_t output_max_len)
-{
-    int ret;
-    size_t ilen, pad_count = 0, i;
-    unsigned char *p, bad, pad_done = 0;
-    unsigned char buf[POLARSSL_MPI_MAX_SIZE];
-
-    if( ctx->padding != RSA_PKCS_V15 )
-        return( POLARSSL_ERR_RSA_BAD_INPUT_DATA );
 
-    ilen = ctx->len;
-
-    if( ilen < 16 || ilen > sizeof( buf ) )
-        return( POLARSSL_ERR_RSA_BAD_INPUT_DATA );
-
-    ret = ( mode == RSA_PUBLIC )
-          ? rsa_public(  ctx, input, buf )
-          : rsa_private( ctx, f_rng, p_rng, input, buf );
-
-    if( ret != 0 )
-        return( ret );
-
-    p = buf;
-    bad = 0;
-
-    /*
-     * Check and get padding len in "constant-time"
-     */
-    bad |= *p++; /* First byte must be 0 */
-
-    /* This test does not depend on secret data */
-    if( mode == RSA_PRIVATE )
-    {
-        bad |= *p++ ^ RSA_CRYPT;
-
-        /* Get padding len, but always read till end of buffer
-         * (minus one, for the 00 byte) */
-        for( i = 0; i < ilen - 3; i++ )
-        {
-            pad_done |= ( p[i] == 0 );
-            pad_count += ( pad_done == 0 );
-        }
-
-        p += pad_count;
-        bad |= *p++; /* Must be zero */
-    }
-    else
-    {
-        bad |= *p++ ^ RSA_SIGN;
-
-        /* Get padding len, but always read till end of buffer
-         * (minus one, for the 00 byte) */
-        for( i = 0; i < ilen - 3; i++ )
-        {
-            pad_done |= ( p[i] == 0xFF );
-            pad_count += ( pad_done == 0 );
-        }
-
-        p += pad_count;
-        bad |= *p++; /* Must be zero */
-    }
-
-    if( bad )
-        return( POLARSSL_ERR_RSA_INVALID_PADDING );
-
-    if (ilen - (p - buf) > output_max_len)
-        return( POLARSSL_ERR_RSA_OUTPUT_TOO_LARGE );
-
-    *olen = ilen - (p - buf);
-    memcpy( output, p, *olen );
-
-    return( 0 );
-}
-#endif /* POLARSSL_PKCS1_V15 */
+#include "rsa.h"
+#include "oid.h"
+#include "md.h"
+#include "asn1.h"
+#include "bignum.h"
 
 /*
- * Do an RSA operation, then remove the message padding
+ * Initialize an RSA context
  */
-int rsa_pkcs1_decrypt( rsa_context *ctx,
-                       int (*f_rng)(void *, unsigned char *, size_t),
-                       void *p_rng,
-                       int mode, size_t *olen,
-                       const unsigned char *input,
-                       unsigned char *output,
-                       size_t output_max_len)
+void rsa_init( rsa_context *ctx,
+               int padding,
+               int hash_id )
 {
-    switch( ctx->padding )
-    {
-#if defined(POLARSSL_PKCS1_V15)
-        case RSA_PKCS_V15:
-            return rsa_rsaes_pkcs1_v15_decrypt( ctx, f_rng, p_rng, mode, olen,
-                                                input, output, output_max_len );
-#endif
-
-#if defined(POLARSSL_PKCS1_V21)
-        case RSA_PKCS_V21:
-            return rsa_rsaes_oaep_decrypt( ctx, f_rng, p_rng, mode, NULL, 0,
-                                           olen, input, output,
-                                           output_max_len );
-#endif
+    memset( ctx, 0, sizeof( rsa_context ) );
 
-        default:
-            return( POLARSSL_ERR_RSA_INVALID_PADDING );
-    }
+    ctx->padding = padding;
+    ctx->hash_id = hash_id;
 }
 
-#if defined(POLARSSL_PKCS1_V21)
 /*
- * Implementation of the PKCS#1 v2.1 RSASSA-PSS-SIGN function
+ * Do an RSA public key operation
  */
-int rsa_rsassa_pss_sign( rsa_context *ctx,
-                         int (*f_rng)(void *, unsigned char *, size_t),
-                         void *p_rng,
-                         int mode,
-                         md_type_t md_alg,
-                         unsigned int hashlen,
-                         const unsigned char *hash,
-                         unsigned char *sig )
+int rsa_public( rsa_context *ctx,
+                const unsigned char *input,
+                unsigned char *output )
 {
-    size_t olen;
-    unsigned char *p = sig;
-    unsigned char salt[POLARSSL_MD_MAX_SIZE];
-    unsigned int slen, hlen, offset = 0;
     int ret;
-    size_t msb;
-    const md_info_t *md_info;
-    md_context_t md_ctx;
-
-    if( ctx->padding != RSA_PKCS_V21 || f_rng == NULL )
-        return( POLARSSL_ERR_RSA_BAD_INPUT_DATA );
-
-    olen = ctx->len;
-
-    if( md_alg != POLARSSL_MD_NONE )
-    {
-        // Gather length of hash to sign
-        //
-        md_info = md_info_from_type( md_alg );
-        if( md_info == NULL )
-            return( POLARSSL_ERR_RSA_BAD_INPUT_DATA );
-
-        hashlen = md_get_size( md_info );
-    }
-
-    md_info = md_info_from_type( ctx->hash_id );
-    if( md_info == NULL )
-        return( POLARSSL_ERR_RSA_BAD_INPUT_DATA );
-
-    hlen = md_get_size( md_info );
-    slen = hlen;
-
-    if( olen < hlen + slen + 2 )
-        return( POLARSSL_ERR_RSA_BAD_INPUT_DATA );
-
-    memset( sig, 0, olen );
-
-    // Generate salt of length slen
-    //
-    if( ( ret = f_rng( p_rng, salt, slen ) ) != 0 )
-        return( POLARSSL_ERR_RSA_RNG_FAILED + ret );
-
-    // Note: EMSA-PSS encoding is over the length of N - 1 bits
-    //
-    msb = mpi_msb( &ctx->N ) - 1;
-    p += olen - hlen * 2 - 2;
-    *p++ = 0x01;
-    memcpy( p, salt, slen );
-    p += slen;
-
-    md_init_ctx( &md_ctx, md_info );
-
-    // Generate H = Hash( M' )
-    //
-    md_starts( &md_ctx );
-    md_update( &md_ctx, p, 8 );
-    md_update( &md_ctx, hash, hashlen );
-    md_update( &md_ctx, salt, slen );
-    md_finish( &md_ctx, p );
-
-    // Compensate for boundary condition when applying mask
-    //
-    if( msb % 8 == 0 )
-        offset = 1;
-
-    // maskedDB: Apply dbMask to DB
-    //
-    mgf_mask( sig + offset, olen - hlen - 1 - offset, p, hlen, &md_ctx );
-
-    md_free_ctx( &md_ctx );
-
-    msb = mpi_msb( &ctx->N ) - 1;
-    sig[0] &= 0xFF >> ( olen * 8 - msb );
-
-    p += hlen;
-    *p++ = 0xBC;
-
-    return( ( mode == RSA_PUBLIC )
-            ? rsa_public(  ctx, sig, sig )
-            : rsa_private( ctx, f_rng, p_rng, sig, sig ) );
-}
-#endif /* POLARSSL_PKCS1_V21 */
-
-#if defined(POLARSSL_PKCS1_V15)
-/*
- * Implementation of the PKCS#1 v2.1 RSASSA-PKCS1-V1_5-SIGN function
- */
-/*
- * Do an RSA operation to sign the message digest
- */
-int rsa_rsassa_pkcs1_v15_sign( rsa_context *ctx,
-                               int (*f_rng)(void *, unsigned char *, size_t),
-                               void *p_rng,
-                               int mode,
-                               md_type_t md_alg,
-                               unsigned int hashlen,
-                               const unsigned char *hash,
-                               unsigned char *sig )
-{
-    size_t nb_pad, olen, oid_size = 0;
-    unsigned char *p = sig;
-    const char *oid;
+    size_t olen;
+    mpi T;
 
-    if( ctx->padding != RSA_PKCS_V15 )
-        return( POLARSSL_ERR_RSA_BAD_INPUT_DATA );
+    mpi_init( &T );
 
-    olen = ctx->len;
-    nb_pad = olen - 3;
+    MPI_CHK( mpi_read_binary( &T, input, ctx->len ) );
 
-    if( md_alg != POLARSSL_MD_NONE )
+    if( mpi_cmp_mpi( &T, &ctx->N ) >= 0 )
     {
-        const md_info_t *md_info = md_info_from_type( md_alg );
-        if( md_info == NULL )
-            return( POLARSSL_ERR_RSA_BAD_INPUT_DATA );
-
-        if( oid_get_oid_by_md( md_alg, &oid, &oid_size ) != 0 )
-            return( POLARSSL_ERR_RSA_BAD_INPUT_DATA );
-
-        nb_pad -= 10 + oid_size;
-
-        hashlen = md_get_size( md_info );
-    }
-
-    nb_pad -= hashlen;
-
-    if( ( nb_pad < 8 ) || ( nb_pad > olen ) )
+        mpi_free( &T );
         return( POLARSSL_ERR_RSA_BAD_INPUT_DATA );
-
-    *p++ = 0;
-    *p++ = RSA_SIGN;
-    memset( p, 0xFF, nb_pad );
-    p += nb_pad;
-    *p++ = 0;
-
-    if( md_alg == POLARSSL_MD_NONE )
-    {
-        memcpy( p, hash, hashlen );
-    }
-    else
-    {
-        /*
-         * DigestInfo ::= SEQUENCE {
-         *   digestAlgorithm DigestAlgorithmIdentifier,
-         *   digest Digest }
-         *
-         * DigestAlgorithmIdentifier ::= AlgorithmIdentifier
-         *
-         * Digest ::= OCTET STRING
-         */
-        *p++ = ASN1_SEQUENCE | ASN1_CONSTRUCTED;
-        *p++ = (unsigned char) ( 0x08 + oid_size + hashlen );
-        *p++ = ASN1_SEQUENCE | ASN1_CONSTRUCTED;
-        *p++ = (unsigned char) ( 0x04 + oid_size );
-        *p++ = ASN1_OID;
-        *p++ = oid_size & 0xFF;
-        memcpy( p, oid, oid_size );
-        p += oid_size;
-        *p++ = ASN1_NULL;
-        *p++ = 0x00;
-        *p++ = ASN1_OCTET_STRING;
-        *p++ = hashlen;
-        memcpy( p, hash, hashlen );
-    }
-
-    return( ( mode == RSA_PUBLIC )
-            ? rsa_public(  ctx, sig, sig )
-            : rsa_private( ctx, f_rng, p_rng, sig, sig ) );
-}
-#endif /* POLARSSL_PKCS1_V15 */
-
-/*
- * Do an RSA operation to sign the message digest
- */
-int rsa_pkcs1_sign( rsa_context *ctx,
-                    int (*f_rng)(void *, unsigned char *, size_t),
-                    void *p_rng,
-                    int mode,
-                    md_type_t md_alg,
-                    unsigned int hashlen,
-                    const unsigned char *hash,
-                    unsigned char *sig )
-{
-    switch( ctx->padding )
-    {
-#if defined(POLARSSL_PKCS1_V15)
-        case RSA_PKCS_V15:
-            return rsa_rsassa_pkcs1_v15_sign( ctx, f_rng, p_rng, mode, md_alg,
-                                              hashlen, hash, sig );
-#endif
-
-#if defined(POLARSSL_PKCS1_V21)
-        case RSA_PKCS_V21:
-            return rsa_rsassa_pss_sign( ctx, f_rng, p_rng, mode, md_alg,
-                                        hashlen, hash, sig );
-#endif
-
-        default:
-            return( POLARSSL_ERR_RSA_INVALID_PADDING );
     }
-}
-
-#if defined(POLARSSL_PKCS1_V21)
-/*
- * Implementation of the PKCS#1 v2.1 RSASSA-PSS-VERIFY function
- */
-int rsa_rsassa_pss_verify( rsa_context *ctx,
-                           int (*f_rng)(void *, unsigned char *, size_t),
-                           void *p_rng,
-                           int mode,
-                           md_type_t md_alg,
-                           unsigned int hashlen,
-                           const unsigned char *hash,
-                           const unsigned char *sig )
-{
-    int ret;
-    size_t siglen;
-    unsigned char *p;
-    unsigned char buf[POLARSSL_MPI_MAX_SIZE];
-    unsigned char result[POLARSSL_MD_MAX_SIZE];
-    unsigned char zeros[8];
-    unsigned int hlen;
-    size_t slen, msb;
-    const md_info_t *md_info;
-    md_context_t md_ctx;
-
-    if( ctx->padding != RSA_PKCS_V21 )
-        return( POLARSSL_ERR_RSA_BAD_INPUT_DATA );
 
-    siglen = ctx->len;
+    olen = ctx->len;
+    MPI_CHK( mpi_exp_mod( &T, &T, &ctx->E, &ctx->N, &ctx->RN ) );
+    MPI_CHK( mpi_write_binary( &T, output, olen ) );
 
-    if( siglen < 16 || siglen > sizeof( buf ) )
-        return( POLARSSL_ERR_RSA_BAD_INPUT_DATA );
+cleanup:
 
-    ret = ( mode == RSA_PUBLIC )
-          ? rsa_public(  ctx, sig, buf )
-          : rsa_private( ctx, f_rng, p_rng, sig, buf );
+    mpi_free( &T );
 
     if( ret != 0 )
-        return( ret );
-
-    p = buf;
-
-    if( buf[siglen - 1] != 0xBC )
-        return( POLARSSL_ERR_RSA_INVALID_PADDING );
-
-    if( md_alg != POLARSSL_MD_NONE )
-    {
-        // Gather length of hash to sign
-        //
-        md_info = md_info_from_type( md_alg );
-        if( md_info == NULL )
-            return( POLARSSL_ERR_RSA_BAD_INPUT_DATA );
-
-        hashlen = md_get_size( md_info );
-    }
-
-    md_info = md_info_from_type( ctx->hash_id );
-    if( md_info == NULL )
-        return( POLARSSL_ERR_RSA_BAD_INPUT_DATA );
-
-    hlen = md_get_size( md_info );
-    slen = siglen - hlen - 1;
-
-    memset( zeros, 0, 8 );
-
-    // Note: EMSA-PSS verification is over the length of N - 1 bits
-    //
-    msb = mpi_msb( &ctx->N ) - 1;
-
-    // Compensate for boundary condition when applying mask
-    //
-    if( msb % 8 == 0 )
-    {
-        p++;
-        siglen -= 1;
-    }
-    if( buf[0] >> ( 8 - siglen * 8 + msb ) )
-        return( POLARSSL_ERR_RSA_BAD_INPUT_DATA );
-
-    md_init_ctx( &md_ctx, md_info );
-
-    mgf_mask( p, siglen - hlen - 1, p + siglen - hlen - 1, hlen, &md_ctx );
-
-    buf[0] &= 0xFF >> ( siglen * 8 - msb );
-
-    while( p < buf + siglen && *p == 0 )
-        p++;
-
-    if( p == buf + siglen ||
-        *p++ != 0x01 )
-    {
-        md_free_ctx( &md_ctx );
-        return( POLARSSL_ERR_RSA_INVALID_PADDING );
-    }
-
-    slen -= p - buf;
-
-    // Generate H = Hash( M' )
-    //
-    md_starts( &md_ctx );
-    md_update( &md_ctx, zeros, 8 );
-    md_update( &md_ctx, hash, hashlen );
-    md_update( &md_ctx, p, slen );
-    md_finish( &md_ctx, result );
-
-    md_free_ctx( &md_ctx );
+        return( POLARSSL_ERR_RSA_PUBLIC_FAILED + ret );
 
-    if( memcmp( p + slen, result, hlen ) == 0 )
-        return( 0 );
-    else
-        return( POLARSSL_ERR_RSA_VERIFY_FAILED );
+    return( 0 );
 }
-#endif /* POLARSSL_PKCS1_V21 */
 
-#if defined(POLARSSL_PKCS1_V15)
 /*
  * Implementation of the PKCS#1 v2.1 RSASSA-PKCS1-v1_5-VERIFY function
  */
@@ -1217,9 +105,10 @@ int rsa_rsassa_pkcs1_v15_verify( rsa_context *ctx,
     if( siglen < 16 || siglen > sizeof( buf ) )
         return( POLARSSL_ERR_RSA_BAD_INPUT_DATA );
 
-    ret = ( mode == RSA_PUBLIC )
-          ? rsa_public(  ctx, sig, buf )
-          : rsa_private( ctx, f_rng, p_rng, sig, buf );
+    if (mode != RSA_PUBLIC)
+	return( POLARSSL_ERR_RSA_BAD_INPUT_DATA );
+
+    ret = rsa_public( ctx, sig, buf );
 
     if( ret != 0 )
         return( ret );
@@ -1254,8 +143,7 @@ int rsa_rsassa_pkcs1_v15_verify( rsa_context *ctx,
 
     end = p + len;
 
-    // Parse the ASN.1 structure inside the PKCS#1 v1.5 structure
-    //
+    /* Parse the ASN.1 structure inside the PKCS#1 v1.5 structure */
     if( ( ret = asn1_get_tag( &p, end, &asn1_len,
             ASN1_CONSTRUCTED | ASN1_SEQUENCE ) ) != 0 )
         return( POLARSSL_ERR_RSA_VERIFY_FAILED );
@@ -1304,7 +192,7 @@ int rsa_rsassa_pkcs1_v15_verify( rsa_context *ctx,
 
     return( 0 );
 }
-#endif /* POLARSSL_PKCS1_V15 */
+
 
 /*
  * Do an RSA operation and check the message digest
@@ -1320,265 +208,10 @@ int rsa_pkcs1_verify( rsa_context *ctx,
 {
     switch( ctx->padding )
     {
-#if defined(POLARSSL_PKCS1_V15)
         case RSA_PKCS_V15:
             return rsa_rsassa_pkcs1_v15_verify( ctx, f_rng, p_rng, mode, md_alg,
                                                 hashlen, hash, sig );
-#endif
-
-#if defined(POLARSSL_PKCS1_V21)
-        case RSA_PKCS_V21:
-            return rsa_rsassa_pss_verify( ctx, f_rng, p_rng, mode, md_alg,
-                                          hashlen, hash, sig );
-#endif
-
         default:
             return( POLARSSL_ERR_RSA_INVALID_PADDING );
     }
 }
-
-/*
- * Copy the components of an RSA key
- */
-int rsa_copy( rsa_context *dst, const rsa_context *src )
-{
-    int ret;
-
-    dst->ver = src->ver;
-    dst->len = src->len;
-
-    MPI_CHK( mpi_copy( &dst->N, &src->N ) );
-    MPI_CHK( mpi_copy( &dst->E, &src->E ) );
-
-    MPI_CHK( mpi_copy( &dst->D, &src->D ) );
-    MPI_CHK( mpi_copy( &dst->P, &src->P ) );
-    MPI_CHK( mpi_copy( &dst->Q, &src->Q ) );
-    MPI_CHK( mpi_copy( &dst->DP, &src->DP ) );
-    MPI_CHK( mpi_copy( &dst->DQ, &src->DQ ) );
-    MPI_CHK( mpi_copy( &dst->QP, &src->QP ) );
-
-    MPI_CHK( mpi_copy( &dst->RN, &src->RN ) );
-    MPI_CHK( mpi_copy( &dst->RP, &src->RP ) );
-    MPI_CHK( mpi_copy( &dst->RQ, &src->RQ ) );
-
-#if !defined(POLARSSL_RSA_NO_CRT)
-    MPI_CHK( mpi_copy( &dst->Vi, &src->Vi ) );
-    MPI_CHK( mpi_copy( &dst->Vf, &src->Vf ) );
-#endif
-
-    dst->padding = src->padding;
-    dst->hash_id = src->padding;
-
-cleanup:
-    if( ret != 0 )
-        rsa_free( dst );
-
-    return( ret );
-}
-
-/*
- * Free the components of an RSA key
- */
-void rsa_free( rsa_context *ctx )
-{
-#if !defined(POLARSSL_RSA_NO_CRT)
-    mpi_free( &ctx->Vi ); mpi_free( &ctx->Vf );
-#endif
-    mpi_free( &ctx->RQ ); mpi_free( &ctx->RP ); mpi_free( &ctx->RN );
-    mpi_free( &ctx->QP ); mpi_free( &ctx->DQ ); mpi_free( &ctx->DP );
-    mpi_free( &ctx->Q  ); mpi_free( &ctx->P  ); mpi_free( &ctx->D );
-    mpi_free( &ctx->E  ); mpi_free( &ctx->N  );
-
-#if defined(POLARSSL_THREADING_C)
-    polarssl_mutex_free( &ctx->mutex );
-#endif
-}
-
-#if defined(POLARSSL_SELF_TEST)
-
-#include "polarssl/sha1.h"
-
-/*
- * Example RSA-1024 keypair, for test purposes
- */
-#define KEY_LEN 128
-
-#define RSA_N   "9292758453063D803DD603D5E777D788" \
-                "8ED1D5BF35786190FA2F23EBC0848AEA" \
-                "DDA92CA6C3D80B32C4D109BE0F36D6AE" \
-                "7130B9CED7ACDF54CFC7555AC14EEBAB" \
-                "93A89813FBF3C4F8066D2D800F7C38A8" \
-                "1AE31942917403FF4946B0A83D3D3E05" \
-                "EE57C6F5F5606FB5D4BC6CD34EE0801A" \
-                "5E94BB77B07507233A0BC7BAC8F90F79"
-
-#define RSA_E   "10001"
-
-#define RSA_D   "24BF6185468786FDD303083D25E64EFC" \
-                "66CA472BC44D253102F8B4A9D3BFA750" \
-                "91386C0077937FE33FA3252D28855837" \
-                "AE1B484A8A9A45F7EE8C0C634F99E8CD" \
-                "DF79C5CE07EE72C7F123142198164234" \
-                "CABB724CF78B8173B9F880FC86322407" \
-                "AF1FEDFDDE2BEB674CA15F3E81A1521E" \
-                "071513A1E85B5DFA031F21ECAE91A34D"
-
-#define RSA_P   "C36D0EB7FCD285223CFB5AABA5BDA3D8" \
-                "2C01CAD19EA484A87EA4377637E75500" \
-                "FCB2005C5C7DD6EC4AC023CDA285D796" \
-                "C3D9E75E1EFC42488BB4F1D13AC30A57"
-
-#define RSA_Q   "C000DF51A7C77AE8D7C7370C1FF55B69" \
-                "E211C2B9E5DB1ED0BF61D0D9899620F4" \
-                "910E4168387E3C30AA1E00C339A79508" \
-                "8452DD96A9A5EA5D9DCA68DA636032AF"
-
-#define RSA_DP  "C1ACF567564274FB07A0BBAD5D26E298" \
-                "3C94D22288ACD763FD8E5600ED4A702D" \
-                "F84198A5F06C2E72236AE490C93F07F8" \
-                "3CC559CD27BC2D1CA488811730BB5725"
-
-#define RSA_DQ  "4959CBF6F8FEF750AEE6977C155579C7" \
-                "D8AAEA56749EA28623272E4F7D0592AF" \
-                "7C1F1313CAC9471B5C523BFE592F517B" \
-                "407A1BD76C164B93DA2D32A383E58357"
-
-#define RSA_QP  "9AE7FBC99546432DF71896FC239EADAE" \
-                "F38D18D2B2F0E2DD275AA977E2BF4411" \
-                "F5A3B2A5D33605AEBBCCBA7FEB9F2D2F" \
-                "A74206CEC169D74BF5A8C50D6F48EA08"
-
-#define PT_LEN  24
-#define RSA_PT  "\xAA\xBB\xCC\x03\x02\x01\x00\xFF\xFF\xFF\xFF\xFF" \
-                "\x11\x22\x33\x0A\x0B\x0C\xCC\xDD\xDD\xDD\xDD\xDD"
-
-#if defined(POLARSSL_PKCS1_V15)
-static int myrand( void *rng_state, unsigned char *output, size_t len )
-{
-    size_t i;
-
-    if( rng_state != NULL )
-        rng_state  = NULL;
-
-    for( i = 0; i < len; ++i )
-        output[i] = rand();
-
-    return( 0 );
-}
-#endif
-
-/*
- * Checkup routine
- */
-int rsa_self_test( int verbose )
-{
-#if defined(POLARSSL_PKCS1_V15)
-    size_t len;
-    rsa_context rsa;
-    unsigned char rsa_plaintext[PT_LEN];
-    unsigned char rsa_decrypted[PT_LEN];
-    unsigned char rsa_ciphertext[KEY_LEN];
-#if defined(POLARSSL_SHA1_C)
-    unsigned char sha1sum[20];
-#endif
-
-    rsa_init( &rsa, RSA_PKCS_V15, 0 );
-
-    rsa.len = KEY_LEN;
-    mpi_read_string( &rsa.N , 16, RSA_N  );
-    mpi_read_string( &rsa.E , 16, RSA_E  );
-    mpi_read_string( &rsa.D , 16, RSA_D  );
-    mpi_read_string( &rsa.P , 16, RSA_P  );
-    mpi_read_string( &rsa.Q , 16, RSA_Q  );
-    mpi_read_string( &rsa.DP, 16, RSA_DP );
-    mpi_read_string( &rsa.DQ, 16, RSA_DQ );
-    mpi_read_string( &rsa.QP, 16, RSA_QP );
-
-    if( verbose != 0 )
-        printf( "  RSA key validation: " );
-
-    if( rsa_check_pubkey(  &rsa ) != 0 ||
-        rsa_check_privkey( &rsa ) != 0 )
-    {
-        if( verbose != 0 )
-            printf( "failed\n" );
-
-        return( 1 );
-    }
-
-    if( verbose != 0 )
-        printf( "passed\n  PKCS#1 encryption : " );
-
-    memcpy( rsa_plaintext, RSA_PT, PT_LEN );
-
-    if( rsa_pkcs1_encrypt( &rsa, myrand, NULL, RSA_PUBLIC, PT_LEN,
-                           rsa_plaintext, rsa_ciphertext ) != 0 )
-    {
-        if( verbose != 0 )
-            printf( "failed\n" );
-
-        return( 1 );
-    }
-
-    if( verbose != 0 )
-        printf( "passed\n  PKCS#1 decryption : " );
-
-    if( rsa_pkcs1_decrypt( &rsa, myrand, NULL, RSA_PRIVATE, &len,
-                           rsa_ciphertext, rsa_decrypted,
-                           sizeof(rsa_decrypted) ) != 0 )
-    {
-        if( verbose != 0 )
-            printf( "failed\n" );
-
-        return( 1 );
-    }
-
-    if( memcmp( rsa_decrypted, rsa_plaintext, len ) != 0 )
-    {
-        if( verbose != 0 )
-            printf( "failed\n" );
-
-        return( 1 );
-    }
-
-#if defined(POLARSSL_SHA1_C)
-    if( verbose != 0 )
-        printf( "passed\n  PKCS#1 data sign  : " );
-
-    sha1( rsa_plaintext, PT_LEN, sha1sum );
-
-    if( rsa_pkcs1_sign( &rsa, myrand, NULL, RSA_PRIVATE, POLARSSL_MD_SHA1, 0,
-                        sha1sum, rsa_ciphertext ) != 0 )
-    {
-        if( verbose != 0 )
-            printf( "failed\n" );
-
-        return( 1 );
-    }
-
-    if( verbose != 0 )
-        printf( "passed\n  PKCS#1 sig. verify: " );
-
-    if( rsa_pkcs1_verify( &rsa, NULL, NULL, RSA_PUBLIC, POLARSSL_MD_SHA1, 0,
-                          sha1sum, rsa_ciphertext ) != 0 )
-    {
-        if( verbose != 0 )
-            printf( "failed\n" );
-
-        return( 1 );
-    }
-
-    if( verbose != 0 )
-        printf( "passed\n\n" );
-#endif /* POLARSSL_SHA1_C */
-
-    rsa_free( &rsa );
-#else /* POLARSSL_PKCS1_V15 */
-    ((void) verbose);
-#endif /* POLARSSL_PKCS1_V15 */
-    return( 0 );
-}
-
-#endif
-
-#endif
--- a/library/sha256.c
+++ b/library/sha256.c
@@ -22,23 +22,10 @@
  *  with this program; if not, write to the Free Software Foundation, Inc.,
  *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
-/*
- *  The SHA-256 Secure Hash Standard was published by NIST in 2002.
- *
- *  http://csrc.nist.gov/publications/fips/fips180-2/fips180-2.pdf
- */
-
-#include "polarssl/config.h"
 
-#if defined(POLARSSL_SHA256_C)
-
-#include "polarssl/sha256.h"
-
-#if defined(POLARSSL_FS_IO) || defined(POLARSSL_SELF_TEST)
-#include <stdio.h>
-#endif
+#include <malloc.h>
 
-#if !defined(POLARSSL_SHA256_ALT)
+#include "sha256.h"
 
 /*
  * 32-bit integer manipulation macros (big endian)
@@ -66,37 +53,21 @@
 /*
  * SHA-256 context setup
  */
-void sha256_starts( sha256_context *ctx, int is224 )
+void sha256_starts(sha256_context *ctx)
 {
-    ctx->total[0] = 0;
-    ctx->total[1] = 0;
-
-    if( is224 == 0 )
-    {
-        /* SHA-256 */
-        ctx->state[0] = 0x6A09E667;
-        ctx->state[1] = 0xBB67AE85;
-        ctx->state[2] = 0x3C6EF372;
-        ctx->state[3] = 0xA54FF53A;
-        ctx->state[4] = 0x510E527F;
-        ctx->state[5] = 0x9B05688C;
-        ctx->state[6] = 0x1F83D9AB;
-        ctx->state[7] = 0x5BE0CD19;
-    }
-    else
-    {
-        /* SHA-224 */
-        ctx->state[0] = 0xC1059ED8;
-        ctx->state[1] = 0x367CD507;
-        ctx->state[2] = 0x3070DD17;
-        ctx->state[3] = 0xF70E5939;
-        ctx->state[4] = 0xFFC00B31;
-        ctx->state[5] = 0x68581511;
-        ctx->state[6] = 0x64F98FA7;
-        ctx->state[7] = 0xBEFA4FA4;
-    }
-
-    ctx->is224 = is224;
+	ctx->total[0] = 0;
+	ctx->total[1] = 0;
+
+	ctx->state[0] = 0x6A09E667;
+	ctx->state[1] = 0xBB67AE85;
+	ctx->state[2] = 0x3C6EF372;
+	ctx->state[3] = 0xA54FF53A;
+	ctx->state[4] = 0x510E527F;
+	ctx->state[5] = 0x9B05688C;
+	ctx->state[6] = 0x1F83D9AB;
+	ctx->state[7] = 0x5BE0CD19;
+
+	ctx->is224 = 0;
 }
 
 void sha256_process( sha256_context *ctx, const unsigned char data[64] )
@@ -233,41 +204,40 @@ void sha256_process( sha256_context *ctx, const unsigned char data[64] )
 /*
  * SHA-256 process buffer
  */
-void sha256_update( sha256_context *ctx, const unsigned char *input, size_t ilen )
+void sha256_update(sha256_context *ctx, const unsigned char *input, size_t ilen)
 {
-    size_t fill;
-    uint32_t left;
-
-    if( ilen <= 0 )
-        return;
-
-    left = ctx->total[0] & 0x3F;
-    fill = 64 - left;
-
-    ctx->total[0] += (uint32_t) ilen;
-    ctx->total[0] &= 0xFFFFFFFF;
-
-    if( ctx->total[0] < (uint32_t) ilen )
-        ctx->total[1]++;
-
-    if( left && ilen >= fill )
-    {
-        memcpy( (void *) (ctx->buffer + left), input, fill );
-        sha256_process( ctx, ctx->buffer );
-        input += fill;
-        ilen  -= fill;
-        left = 0;
-    }
-
-    while( ilen >= 64 )
-    {
-        sha256_process( ctx, input );
-        input += 64;
-        ilen  -= 64;
-    }
-
-    if( ilen > 0 )
-        memcpy( (void *) (ctx->buffer + left), input, ilen );
+	size_t fill;
+	uint32_t left;
+
+	if( ilen <= 0 )
+		return;
+
+	left = ctx->total[0] & 0x3F;
+	fill = 64 - left;
+
+	ctx->total[0] += (uint32_t) ilen;
+	ctx->total[0] &= 0xFFFFFFFF;
+
+	if( ctx->total[0] < (uint32_t) ilen )
+		ctx->total[1]++;
+
+	if( left && ilen >= fill ) {
+		memcpy( (void *) (ctx->buffer + left), input, fill );
+		sha256_process( ctx, ctx->buffer );
+		input += fill;
+		ilen  -= fill;
+		left = 0;
+	}
+
+	while( ilen >= 64 )
+	{
+		sha256_process( ctx, input );
+		input += 64;
+		ilen  -= 64;
+	}
+
+	if( ilen > 0 )
+		memcpy( (void *) (ctx->buffer + left), input, ilen );
 }
 
 static const unsigned char sha256_padding[64] =
@@ -312,8 +282,6 @@ void sha256_finish( sha256_context *ctx, unsigned char output[32] )
         PUT_UINT32_BE( ctx->state[7], output, 28 );
 }
 
-#endif /* !POLARSSL_SHA256_ALT */
-
 /*
  * output = SHA-256( input buffer )
  */
@@ -322,47 +290,13 @@ void sha256( const unsigned char *input, size_t ilen,
 {
     sha256_context ctx;
 
-    sha256_starts( &ctx, is224 );
+    sha256_starts( &ctx);
     sha256_update( &ctx, input, ilen );
     sha256_finish( &ctx, output );
 
     memset( &ctx, 0, sizeof( sha256_context ) );
 }
 
-#if defined(POLARSSL_FS_IO)
-/*
- * output = SHA-256( file contents )
- */
-int sha256_file( const char *path, unsigned char output[32], int is224 )
-{
-    FILE *f;
-    size_t n;
-    sha256_context ctx;
-    unsigned char buf[1024];
-
-    if( ( f = fopen( path, "rb" ) ) == NULL )
-        return( POLARSSL_ERR_SHA256_FILE_IO_ERROR );
-
-    sha256_starts( &ctx, is224 );
-
-    while( ( n = fread( buf, 1, sizeof( buf ), f ) ) > 0 )
-        sha256_update( &ctx, buf, n );
-
-    sha256_finish( &ctx, output );
-
-    memset( &ctx, 0, sizeof( sha256_context ) );
-
-    if( ferror( f ) != 0 )
-    {
-        fclose( f );
-        return( POLARSSL_ERR_SHA256_FILE_IO_ERROR );
-    }
-
-    fclose( f );
-    return( 0 );
-}
-#endif /* POLARSSL_FS_IO */
-
 /*
  * SHA-256 HMAC context setup
  */
@@ -388,7 +322,7 @@ void sha256_hmac_starts( sha256_context *ctx, const unsigned char *key,
         ctx->opad[i] = (unsigned char)( ctx->opad[i] ^ key[i] );
     }
 
-    sha256_starts( ctx, is224 );
+    sha256_starts( ctx );
     sha256_update( ctx, ctx->ipad, 64 );
 
     memset( sum, 0, sizeof( sum ) );
@@ -414,7 +348,7 @@ void sha256_hmac_finish( sha256_context *ctx, unsigned char output[32] )
     hlen = ( is224 == 0 ) ? 32 : 28;
 
     sha256_finish( ctx, tmpbuf );
-    sha256_starts( ctx, is224 );
+    sha256_starts( ctx );
     sha256_update( ctx, ctx->opad, 64 );
     sha256_update( ctx, tmpbuf, hlen );
     sha256_finish( ctx, output );
@@ -427,7 +361,7 @@ void sha256_hmac_finish( sha256_context *ctx, unsigned char output[32] )
  */
 void sha256_hmac_reset( sha256_context *ctx )
 {
-    sha256_starts( ctx, ctx->is224 );
+    sha256_starts( ctx );
     sha256_update( ctx, ctx->ipad, 64 );
 }
 
@@ -447,259 +381,5 @@ void sha256_hmac( const unsigned char *key, size_t keylen,
     memset( &ctx, 0, sizeof( sha256_context ) );
 }
 
-#if defined(POLARSSL_SELF_TEST)
-/*
- * FIPS-180-2 test vectors
- */
-static unsigned char sha256_test_buf[3][57] = 
-{
-    { "abc" },
-    { "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq" },
-    { "" }
-};
-
-static const int sha256_test_buflen[3] =
-{
-    3, 56, 1000
-};
-
-static const unsigned char sha256_test_sum[6][32] =
-{
-    /*
-     * SHA-224 test vectors
-     */
-    { 0x23, 0x09, 0x7D, 0x22, 0x34, 0x05, 0xD8, 0x22,
-      0x86, 0x42, 0xA4, 0x77, 0xBD, 0xA2, 0x55, 0xB3,
-      0x2A, 0xAD, 0xBC, 0xE4, 0xBD, 0xA0, 0xB3, 0xF7,
-      0xE3, 0x6C, 0x9D, 0xA7 },
-    { 0x75, 0x38, 0x8B, 0x16, 0x51, 0x27, 0x76, 0xCC,
-      0x5D, 0xBA, 0x5D, 0xA1, 0xFD, 0x89, 0x01, 0x50,
-      0xB0, 0xC6, 0x45, 0x5C, 0xB4, 0xF5, 0x8B, 0x19,
-      0x52, 0x52, 0x25, 0x25 },
-    { 0x20, 0x79, 0x46, 0x55, 0x98, 0x0C, 0x91, 0xD8,
-      0xBB, 0xB4, 0xC1, 0xEA, 0x97, 0x61, 0x8A, 0x4B,
-      0xF0, 0x3F, 0x42, 0x58, 0x19, 0x48, 0xB2, 0xEE,
-      0x4E, 0xE7, 0xAD, 0x67 },
-
-    /*
-     * SHA-256 test vectors
-     */
-    { 0xBA, 0x78, 0x16, 0xBF, 0x8F, 0x01, 0xCF, 0xEA,
-      0x41, 0x41, 0x40, 0xDE, 0x5D, 0xAE, 0x22, 0x23,
-      0xB0, 0x03, 0x61, 0xA3, 0x96, 0x17, 0x7A, 0x9C,
-      0xB4, 0x10, 0xFF, 0x61, 0xF2, 0x00, 0x15, 0xAD },
-    { 0x24, 0x8D, 0x6A, 0x61, 0xD2, 0x06, 0x38, 0xB8,
-      0xE5, 0xC0, 0x26, 0x93, 0x0C, 0x3E, 0x60, 0x39,
-      0xA3, 0x3C, 0xE4, 0x59, 0x64, 0xFF, 0x21, 0x67,
-      0xF6, 0xEC, 0xED, 0xD4, 0x19, 0xDB, 0x06, 0xC1 },
-    { 0xCD, 0xC7, 0x6E, 0x5C, 0x99, 0x14, 0xFB, 0x92,
-      0x81, 0xA1, 0xC7, 0xE2, 0x84, 0xD7, 0x3E, 0x67,
-      0xF1, 0x80, 0x9A, 0x48, 0xA4, 0x97, 0x20, 0x0E,
-      0x04, 0x6D, 0x39, 0xCC, 0xC7, 0x11, 0x2C, 0xD0 }
-};
-
-/*
- * RFC 4231 test vectors
- */
-static unsigned char sha256_hmac_test_key[7][26] =
-{
-    { "\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B"
-      "\x0B\x0B\x0B\x0B" },
-    { "Jefe" },
-    { "\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA"
-      "\xAA\xAA\xAA\xAA" },
-    { "\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F\x10"
-      "\x11\x12\x13\x14\x15\x16\x17\x18\x19" },
-    { "\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C"
-      "\x0C\x0C\x0C\x0C" },
-    { "" }, /* 0xAA 131 times */
-    { "" }
-};
-
-static const int sha256_hmac_test_keylen[7] =
-{
-    20, 4, 20, 25, 20, 131, 131
-};
-
-static unsigned char sha256_hmac_test_buf[7][153] =
-{
-    { "Hi There" },
-    { "what do ya want for nothing?" },
-    { "\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD"
-      "\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD"
-      "\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD"
-      "\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD"
-      "\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD" },
-    { "\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD"
-      "\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD"
-      "\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD"
-      "\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD"
-      "\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD" },
-    { "Test With Truncation" },
-    { "Test Using Larger Than Block-Size Key - Hash Key First" },
-    { "This is a test using a larger than block-size key "
-      "and a larger than block-size data. The key needs to "
-      "be hashed before being used by the HMAC algorithm." }
-};
-
-static const int sha256_hmac_test_buflen[7] =
-{
-    8, 28, 50, 50, 20, 54, 152
-};
-
-static const unsigned char sha256_hmac_test_sum[14][32] =
-{
-    /*
-     * HMAC-SHA-224 test vectors
-     */
-    { 0x89, 0x6F, 0xB1, 0x12, 0x8A, 0xBB, 0xDF, 0x19,
-      0x68, 0x32, 0x10, 0x7C, 0xD4, 0x9D, 0xF3, 0x3F,
-      0x47, 0xB4, 0xB1, 0x16, 0x99, 0x12, 0xBA, 0x4F,
-      0x53, 0x68, 0x4B, 0x22 },
-    { 0xA3, 0x0E, 0x01, 0x09, 0x8B, 0xC6, 0xDB, 0xBF,
-      0x45, 0x69, 0x0F, 0x3A, 0x7E, 0x9E, 0x6D, 0x0F,
-      0x8B, 0xBE, 0xA2, 0xA3, 0x9E, 0x61, 0x48, 0x00,
-      0x8F, 0xD0, 0x5E, 0x44 },
-    { 0x7F, 0xB3, 0xCB, 0x35, 0x88, 0xC6, 0xC1, 0xF6,
-      0xFF, 0xA9, 0x69, 0x4D, 0x7D, 0x6A, 0xD2, 0x64,
-      0x93, 0x65, 0xB0, 0xC1, 0xF6, 0x5D, 0x69, 0xD1,
-      0xEC, 0x83, 0x33, 0xEA },
-    { 0x6C, 0x11, 0x50, 0x68, 0x74, 0x01, 0x3C, 0xAC,
-      0x6A, 0x2A, 0xBC, 0x1B, 0xB3, 0x82, 0x62, 0x7C,
-      0xEC, 0x6A, 0x90, 0xD8, 0x6E, 0xFC, 0x01, 0x2D,
-      0xE7, 0xAF, 0xEC, 0x5A },
-    { 0x0E, 0x2A, 0xEA, 0x68, 0xA9, 0x0C, 0x8D, 0x37,
-      0xC9, 0x88, 0xBC, 0xDB, 0x9F, 0xCA, 0x6F, 0xA8 },
-    { 0x95, 0xE9, 0xA0, 0xDB, 0x96, 0x20, 0x95, 0xAD,
-      0xAE, 0xBE, 0x9B, 0x2D, 0x6F, 0x0D, 0xBC, 0xE2,
-      0xD4, 0x99, 0xF1, 0x12, 0xF2, 0xD2, 0xB7, 0x27,
-      0x3F, 0xA6, 0x87, 0x0E },
-    { 0x3A, 0x85, 0x41, 0x66, 0xAC, 0x5D, 0x9F, 0x02,
-      0x3F, 0x54, 0xD5, 0x17, 0xD0, 0xB3, 0x9D, 0xBD,
-      0x94, 0x67, 0x70, 0xDB, 0x9C, 0x2B, 0x95, 0xC9,
-      0xF6, 0xF5, 0x65, 0xD1 },
-
-    /*
-     * HMAC-SHA-256 test vectors
-     */
-    { 0xB0, 0x34, 0x4C, 0x61, 0xD8, 0xDB, 0x38, 0x53,
-      0x5C, 0xA8, 0xAF, 0xCE, 0xAF, 0x0B, 0xF1, 0x2B,
-      0x88, 0x1D, 0xC2, 0x00, 0xC9, 0x83, 0x3D, 0xA7,
-      0x26, 0xE9, 0x37, 0x6C, 0x2E, 0x32, 0xCF, 0xF7 },
-    { 0x5B, 0xDC, 0xC1, 0x46, 0xBF, 0x60, 0x75, 0x4E,
-      0x6A, 0x04, 0x24, 0x26, 0x08, 0x95, 0x75, 0xC7,
-      0x5A, 0x00, 0x3F, 0x08, 0x9D, 0x27, 0x39, 0x83,
-      0x9D, 0xEC, 0x58, 0xB9, 0x64, 0xEC, 0x38, 0x43 },
-    { 0x77, 0x3E, 0xA9, 0x1E, 0x36, 0x80, 0x0E, 0x46,
-      0x85, 0x4D, 0xB8, 0xEB, 0xD0, 0x91, 0x81, 0xA7,
-      0x29, 0x59, 0x09, 0x8B, 0x3E, 0xF8, 0xC1, 0x22,
-      0xD9, 0x63, 0x55, 0x14, 0xCE, 0xD5, 0x65, 0xFE },
-    { 0x82, 0x55, 0x8A, 0x38, 0x9A, 0x44, 0x3C, 0x0E,
-      0xA4, 0xCC, 0x81, 0x98, 0x99, 0xF2, 0x08, 0x3A,
-      0x85, 0xF0, 0xFA, 0xA3, 0xE5, 0x78, 0xF8, 0x07,
-      0x7A, 0x2E, 0x3F, 0xF4, 0x67, 0x29, 0x66, 0x5B },
-    { 0xA3, 0xB6, 0x16, 0x74, 0x73, 0x10, 0x0E, 0xE0,
-      0x6E, 0x0C, 0x79, 0x6C, 0x29, 0x55, 0x55, 0x2B },
-    { 0x60, 0xE4, 0x31, 0x59, 0x1E, 0xE0, 0xB6, 0x7F,
-      0x0D, 0x8A, 0x26, 0xAA, 0xCB, 0xF5, 0xB7, 0x7F,
-      0x8E, 0x0B, 0xC6, 0x21, 0x37, 0x28, 0xC5, 0x14,
-      0x05, 0x46, 0x04, 0x0F, 0x0E, 0xE3, 0x7F, 0x54 },
-    { 0x9B, 0x09, 0xFF, 0xA7, 0x1B, 0x94, 0x2F, 0xCB,
-      0x27, 0x63, 0x5F, 0xBC, 0xD5, 0xB0, 0xE9, 0x44,
-      0xBF, 0xDC, 0x63, 0x64, 0x4F, 0x07, 0x13, 0x93,
-      0x8A, 0x7F, 0x51, 0x53, 0x5C, 0x3A, 0x35, 0xE2 }
-};
-
-/*
- * Checkup routine
- */
-int sha256_self_test( int verbose )
-{
-    int i, j, k, buflen;
-    unsigned char buf[1024];
-    unsigned char sha256sum[32];
-    sha256_context ctx;
-
-    for( i = 0; i < 6; i++ )
-    {
-        j = i % 3;
-        k = i < 3;
-
-        if( verbose != 0 )
-            printf( "  SHA-%d test #%d: ", 256 - k * 32, j + 1 );
 
-        sha256_starts( &ctx, k );
 
-        if( j == 2 )
-        {
-            memset( buf, 'a', buflen = 1000 );
-
-            for( j = 0; j < 1000; j++ )
-                sha256_update( &ctx, buf, buflen );
-        }
-        else
-            sha256_update( &ctx, sha256_test_buf[j],
-                                 sha256_test_buflen[j] );
-
-        sha256_finish( &ctx, sha256sum );
-
-        if( memcmp( sha256sum, sha256_test_sum[i], 32 - k * 4 ) != 0 )
-        {
-            if( verbose != 0 )
-                printf( "failed\n" );
-
-            return( 1 );
-        }
-
-        if( verbose != 0 )
-            printf( "passed\n" );
-    }
-
-    if( verbose != 0 )
-        printf( "\n" );
-
-    for( i = 0; i < 14; i++ )
-    {
-        j = i % 7;
-        k = i < 7;
-
-        if( verbose != 0 )
-            printf( "  HMAC-SHA-%d test #%d: ", 256 - k * 32, j + 1 );
-
-        if( j == 5 || j == 6 )
-        {
-            memset( buf, '\xAA', buflen = 131 );
-            sha256_hmac_starts( &ctx, buf, buflen, k );
-        }
-        else
-            sha256_hmac_starts( &ctx, sha256_hmac_test_key[j],
-                                      sha256_hmac_test_keylen[j], k );
-
-        sha256_hmac_update( &ctx, sha256_hmac_test_buf[j],
-                                  sha256_hmac_test_buflen[j] );
-
-        sha256_hmac_finish( &ctx, sha256sum );
-
-        buflen = ( j == 4 ) ? 16 : 32 - k * 4;
-
-        if( memcmp( sha256sum, sha256_hmac_test_sum[i], buflen ) != 0 )
-        {
-            if( verbose != 0 )
-                printf( "failed\n" );
-
-            return( 1 );
-        }
-
-        if( verbose != 0 )
-            printf( "passed\n" );
-    }
-
-    if( verbose != 0 )
-        printf( "\n" );
-
-    return( 0 );
-}
-
-#endif
-
-#endif
